[{"content":"Python代码的单元测试 单元测试的概念 定义：是指对软件中的最小可测试单元进行检查和验证。 作用：可以确保程序模块是否否和我们规范的输出，保证该模块经过修改后仍然是满足我们的需求。 单元测试的策略 如果要创建单元测试，可以遵循如下基本技巧来确保涵盖所有的测试用例。\n逻辑检查：给定正确的、符合预期的输入，系统是否能够执行正确的计算并遵循通过代码正确的路径？给定的输入是否涵盖通过代码的所有路径？ 边界检查：对于给定的输入，系统如何响应？ 系统如何响应典型输入、边缘用例或无效输入？假设您期望输入的整数介于 3 和 7 之间。当您使用 5（典型输入）、3（边缘用例）或 9（无效输入）时，系统会如何响应？ 错误处理：当输入中出现错误时，系统会如何响应？ 是否提示用户输入其他内容？ 软件是否会崩溃？ 面向对象的检查：如果通过运行代码更改任何持久对象的状态，则该对象是否正确更新？ 单元测试类的编写 首先编写要进行单元测试的代码。\ndef add(x, y): \u0026#34;\u0026#34;\u0026#34;加法函数\u0026#34;\u0026#34;\u0026#34; return x + y def subtract(x, y): \u0026#34;\u0026#34;\u0026#34;减法函数\u0026#34;\u0026#34;\u0026#34; return x - y def multiply(x, y): \u0026#34;\u0026#34;\u0026#34;乘法函数\u0026#34;\u0026#34;\u0026#34; return x * y def divide(x, y): \u0026#34;\u0026#34;\u0026#34;除法函数\u0026#34;\u0026#34;\u0026#34; if y != 0: return x / y else: return ValueError(\u0026#34;除数不能为0\u0026#34;) 编写测试工具代码。\n# 测试代码应使用test_xxx的名称进行规范 # 这里使用断言assert进行模拟 # assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常 # 如下代码执行正常不报错，则说明函数执行符合预期 from myfunctions import divide # 一个简单的单元测试示例 def test_divide(x, y, result): r = divide(x, y) assert result == r def test_divide_error(x, y): try: divide(x, y) except ValueError: assert False 执行单元测试的工具代码。\n单元测试执行完成，无错误输出代码执行符合预期。\nPython中的单元测试类 如上的代码能够满足Python中进行单元测试的需求，但如果换一套方法，我们的单元测试又需要手动编码，Python中提供了专业的单元测试工具类：unittest，以下是该单元测试类的使用方法介绍。\nunittest 将我们常规用到的测试场景封装了以下断言方法，根据测试所需要的场景进行引用。\n断言方法 方法解释 assertEqual(a, b) 检查a 和b 是否相等。 assertNotEqual(a, b) 检查a 和b 是否不相等。 assertTrue(x) 检查x 是否为True。 assertFalse(x) 检查x 是否为False。 assertIs(a, b) 检查a 和b 是否为同一对象（is）。 assertIsNot(a, b) 检查a 和b 是否不是同一对象。 assertIsNone(x) 检查x 是否为None。 assertIsNotNone(x) 检查x 是否不是None。 assertIn(a, b) 检查a 是否在b 中。 assertNotIn(a, b) 检查a 是否不在b 中。 assertIsInstance(a, b) 检查a 是否为b 类型的实例。 assertNotIsInstance(a, b) 检查a 是否不是b 类型的实例。 assertAlmostEqual(a, b) 检查a 和b 是否近似相等（适用于浮点数比较）。 assertNotAlmostEqual(a, b) 检查a 和b 是否不近似相等（适用于浮点数比较）。 assertRaises(Error, func, *args, **kwargs) 检查当调用function 时是否抛出了Error 异常。 unittest模块的基础使用 单元测试代码：\n# unittest 是python自带的工具包，无需单独下载 import unittest from myfunctions import * class TestMyFunctions(unittest.TestCase): def test_add(self): # assertEqual，断言测试方法，`unittest` 将我们常规用到的测试场景封装成断言方法，根据测试所需要的场景进行引用。 self.assertEqual(add(1, 2), 3) self.assertEqual(add(-1, 2), 1) self.assertEqual(add(-1, -2), -3) def test_subtract(self): self.assertEqual(subtract(1, 2), -1) self.assertEqual(subtract(-1, 2), -3) self.assertEqual(subtract(-1, -2), 1) def test_multiply(self): self.assertEqual(multiply(1, 2), 2) self.assertEqual(multiply(-1, 2), -2) self.assertEqual(multiply(-1, -2), 2) def test_divide(self): self.assertEqual(divide(1, 2), 0.5) self.assertEqual(divide(-1, 2), -0.5) self.assertEqual(divide(-1, -2), 0.5) unittest 代码并不能够直接运行，有以下执行方法：\n命令行：\npython -m unittest test_myfunctions.py 注意：这里的启动如果写成 python.exe -m unittest .\\test_myfunctions.py 会报如下错误。\nmain 函数：\nif __name__ == \u0026#39;__main__\u0026#39;: unittest.main() unittest模块的前置方法 在实际的测试中可能同时存在多个前置相同的测试，unittest模块提供了setUp()用于在测试开始前执行相关环境的设置，tearDown() 在 setUp() 方法之后进行执行。\n注：这里的 setUp 和 tearDown 是固定的函数名，不允许更改。\n要测试的代码：\ndef divide(x, y): \u0026#34;\u0026#34;\u0026#34;除法函数\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;divide called\u0026#34;) if y != 0: return x / y else: raise ValueError(\u0026#34;除数不能为0\u0026#34;) 测试工具类：\nimport unittest from myfunctions import * class TestMyFunctions(unittest.TestCase): def setUp(self): self.test_value_a = 10 self.test_value_b = 5 self.test_value_c = 0 print(\u0026#34;setUp called\u0026#34;) def tearDown(self): del self.test_value_a del self.test_value_b del self.test_value_c print(\u0026#34;tearDown called\u0026#34;) def test_divide(self): self.assertEqual(divide(self.test_value_a, self.test_value_b), 2) self.assertRaises(ValueError, divide, self.test_value_a, self.test_value_c) if __name__ == \u0026#39;__main__\u0026#39;: unittest.main() 代码执行测试：\n可以看到，在执行函数测试之前，首先调用了 setUp() 前置方法，然后执行测试，测试结束后，调用 tearDown() 清理单元测试。\n测试覆盖率 覆盖率是用来度量测试完整性的手段,是测试效果衡量的标准,是测试技术有效性的度量: 覆盖率 = (至少被执行一次的项目(item)数) / (项目的总数)\nPython中提供了测试覆盖率的模块类：coverage，该第三方包需要手动安装。\n这里使用如下方法直接进行代码的测试覆盖率分析\n# 调用单元测试工具类 coverage run -m unittest discover # 输出测试报告 coverage report 这里的代码测试覆盖率较低，对单元测试工具类进行优化，要测试的代码如下：\ndef add(x, y): \u0026#34;\u0026#34;\u0026#34;加法函数\u0026#34;\u0026#34;\u0026#34; return x + y def subtract(x, y): \u0026#34;\u0026#34;\u0026#34;减法函数\u0026#34;\u0026#34;\u0026#34; return x - y def multiply(x, y): \u0026#34;\u0026#34;\u0026#34;乘法函数\u0026#34;\u0026#34;\u0026#34; return x * y def divide(x, y): \u0026#34;\u0026#34;\u0026#34;除法函数\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;divide called\u0026#34;) if y != 0: return x / y else: raise ValueError(\u0026#34;除数不能为0\u0026#34;) 优化后的单元测试方法为：\nimport unittest from myfunctions import * class TestMyFunctions(unittest.TestCase): def setUp(self): self.test_value_a = 10 self.test_value_b = 5 self.test_value_c = 0 print(\u0026#34;setUp called\u0026#34;) def tearDown(self): del self.test_value_a del self.test_value_b del self.test_value_c print(\u0026#34;tearDown called\u0026#34;) def test_add(self): self.assertEqual(add(self.test_value_a, self.test_value_b), 15) self.assertEqual(add(self.test_value_a, self.test_value_c), 10) def test_subtract(self): self.assertEqual(subtract(self.test_value_a, self.test_value_b), 5) self.assertEqual(subtract(self.test_value_a, self.test_value_c), 10) def test_multiply(self): self.assertEqual(multiply(self.test_value_a, self.test_value_b), 50) self.assertEqual(multiply(self.test_value_a, self.test_value_c), 0) def test_divide(self): self.assertEqual(divide(self.test_value_a, self.test_value_b), 2) self.assertRaises(ValueError, divide, self.test_value_a, self.test_value_c) if __name__ == \u0026#39;__main__\u0026#39;: unittest.main() 结果测试\n","date":"2024-02-14T01:00:00+08:00","image":"https://euansu123.github.io/img/Python%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.jpg","permalink":"https://euansu123.github.io/post/python_unittest/","title":"Python代码的单元测试"},{"content":"Django 1.Django 介绍 1.1 组件 Django 包含的组件如下：\n基本配置文件/路由系统 模型层(M)/模板层(T)/视图层(V) Cookies 和 Session 分页及分发邮件 Admin 管理后台 1.2 用途 Django 能够实现所有 HTTP 请求处理。\n网站/微信公众号/小程序后端开发 人工智能平台融合 1.3 版本 Django 官网：The web framework for perfectionists with deadlines | Django (djangoproject.com) Django 中文文档参考网站：一译 (yiyibooks.cn) 版本： 教程版本：2.2.12 1.4 安装 1.4.1 在线安装 pip install django==2.2.12 1.4.2 离线安装 # 将安装包下载到本地 # 解压缩并进入到解压缩后的目录 # 执行如下命令进行安装 python setup.py install # 执行如下命令检查是否安装成功 pip freeze | grep -i \u0026#39;Django\u0026#39; 2.Django 的项目结构 2.1 创建项目 成功安装 Django 后，虚拟机终端会有 django-admin 命令\n执行 django-admin startproject [项目名] 即可创建出对应项目的文件夹\n# 创建 mysite1 项目 django-admin startproject mysite1 2.2 启动服务 启动[测试开发阶段] 终端 cd 进入到项目文件夹\n进入到项目文件夹后，执行 python manage.py runserver [端口] 启动 django 服务，端口不指定即为 8000。\n浏览器访问 http://127.0.0.1:8000 可看到 django 的启动页面。\n2.3 关闭服务 关闭服务[测试开发阶段]\n方式一[在runserver启动终端下]：\n执行 ctrl + c 可退出 Django 服务。\n方式二[在其他终端下]：\n执行 sudo lsof -i:8000 查询出 Django 的进程 id。\n执行 kill -9 Django 进程的 id。\n2.4 项目结构解析 mysite ├── db.sqlite3 [Django默认的数据库，sqlite] ├── manage.py └── mysite ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-310.pyc │ ├── settings.cpython-310.pyc │ ├── urls.cpython-310.pyc │ └── wsgi.cpython-310.pyc ├── settings.py ├── urls.py └── wsgi.py manage.py\n包含项目管理的子命令，如：\n# 启动服务 python manage.py runserver # 创建应用 python manage.py startapp [appname] # 生成迁移文件 python manage.py makemigrations # 数据迁移 python manage.py migrate ... # 直接执行 python manage.py 会列出所有Django的子命令 项目同名文件夹 - mysite/mysite\n__init__ : Python 包的初始化文件。 wsgi.py : web 服务网关配置文件，Django 正式启动时，需要用到。 urls.py : 项目的主路由配置，Http 请求进入 Django 时，优先调用该文件。 settings.py : 项目的配置文件，包含项目启动时需要的配置。 项目配置文件 - settings.py\nsettings.py 包含了 Django 项目启动时所有的配置项。\n配置项分为公有配置和自定义配置。\n配置项格式：BASE_DIR = \u0026lsquo;xxxx\u0026rsquo;。\n公有配置，Django官方提供的基础配置，可到如下网站查询。\nhttps://docs.djangoproject.com/en/2.2/ref/settings/ ALLOWED_HOSTS\n设置允许访问到本项目的 host 头值。\n示例：如果要在局域网其他主机也能访问此主机的Django服务，启动方式如下：\n(1) python3 manage.py runserver 0.0.0.0:5000\n(2) 指定网络设备如果内网环境下其他主机想正常访问该站点，需要添加 ALLOWED_HOSTS = [\u0026lsquo;内网IP\u0026rsquo;]\n在 windows 主机访问虚拟机启动的 Django 项目，显示主机ip应该添加到 ALLOWED_HOSTS，在 settings.py 添加后，再次访问，页面能够被正常文件。\nLANGUAGE_CODE\n设置项目的页面展示语言，简体中文设置为：zh-Hans。\nTIME_ZONE\n用于指定当前服务端时区，默认为格林威治时间(UTC)，中国地区设置为 Asia/Shanghai。\nBASE_DIR\n用于绑定当前项目的绝对路径（动态计算出来的），所有文件夹都可以依赖此路径。\nDEBUG\n用于配置 Django 项目的启动模式，取值：True，表示开发环境中使用；False，表示当前项目运行在生产环境中。\nINSTALLED_APPS\n指定当前项目中安装的应用列表。\nMIDDLEWARE\n用于注册中间件。\nTEMPLATES\n用于指定模板的配置信息。\nDATABASES\n用于指定数据库的配置信息。\nROOT_URLCONF\n用于配置主 url 配置，ROOT_URLCONF = 'mysite.urls'。\n3.URL 和 视图函数 3.1 URL 定义：即统一资源定位符 Uniform Resource Locator\n作用：用来表示互联网上某个资源的地址\nURL的一般语法为：\n# portocol:协议(http、https、file) # hostname:主机名 # port:端口 # path:路由地址 # query:查询的参数，可有多个参数，用 \u0026amp; 隔开，每个参数的名和值用 = 隔开。 # fragment:信息片段，字符串，用于指定网络资源中的片段。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。 protocol://hostname[:port]/path[?query][#fragment] 例如：\n# 直接定位到页面指定信息片段的位置 https://docs.djangoproject.com/en/4.2/#how-the-documentation-is-organized 3.2 处理 URL 请求 以URL（http://127.0.0.1:8000/page/2003）为例。\nDjango 从配置文件中根据 ROOT_URLCONF 找到主路由文件；默认情况下，该文件为项目同名目录下的 urls.py。 Django 加载主路由文件中的 urlpatterns 变量[包含很多路由的数组]。 依次匹配 urlpatterns 中的 path ，匹配到第一个合适的中断后续匹配。 匹配成功-调用对应的视图函数处理请求，返回响应。 匹配失败-返回 404 响应。 主路由 - urls.py\nfrom django.contrib import admin from django.urls import path from . import views urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;page/2023\u0026#39;, views.page_2023), path(\u0026#39;page/2024\u0026#39;, views.page_2024) ] 3.3 视图函数 定义：视图函数是用于接收一个浏览器请求（HttpRequest对象）并通过HttpResponse对象返回响应的函数，此函数可以接收浏览器请求并根据业务逻辑返回响应的响应内容给浏览器。\n语法：\ndef xxx_view(request[,其他参数]): return HttpResponse 对象 样例：\nfrom django.http import HttpResponse def page_2023(request): html = \u0026#34;\u0026lt;h1\u0026gt;这是第一个页面\u0026lt;/h1\u0026gt;\u0026#34; return HttpResponse(html) 4.路由配置 settings.py 中的 ROOT_URLCONF 指定了主路由配置列表 urlpatterns 的文件位置。\nurlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;page/2023/\u0026#39;, views.page_2023), path(\u0026#39;page/2024/\u0026#39;, views.page_2024), ... # 配置URL和视图函数 ] 4.1 path 函数 path函数定义\n# 导入 from django.urls import path # 语法 path(route,views,[name=]) # 参数 route:字符串类型，匹配请求路径 views:指定路径所对应视图函数的名称 name:为路由地址起别名，在模板中地址反向解析时使用 4.2 path 转换器 # 语法 \u0026lt;转换器类型:自定义名\u0026gt; # 作用 如果转换器类型匹配到对应类型的数据，则将数据按照关键字传参的方式传递给视图函数 # 例如 path(\u0026#39;page/\\\u0026lt;int:page\u0026gt;\u0026#39;,views.xxx) 转换器列表\n转换器类型 作用 样例 str 匹配除了\u0026rsquo;/\u0026lsquo;之外的非空字符串 v1/users/\u0026lt;str:username\u0026gt;匹配 /v1/users/guoxiaonao int 匹配0或者任意正整数，返回一个int page/\u0026lt;int:page\u0026gt; 匹配 /page/100 slug 匹配任意由 ASCII字母或数字以及连字符和下划线组成的短标签 detail/\u0026lt;slug:sl\u0026gt; 匹配 /detail/this-is-django path 匹配非空字段，包括路径分隔符\u0026rsquo;/\u0026rsquo; v1/users/\u0026lt;path:ph\u0026gt; 匹配 /v1/goods/a/b/c 转换器测试\nint 转换器测试\n# URL urlpatterns = [ ... path(\u0026#39;page/\u0026lt;int:number\u0026gt;\u0026#39;, views.page_n) ] # 视图函数 def page_n(request,number): html = \u0026#34;\u0026lt;h1\u0026gt;这是第{number}个页面\u0026lt;/h1\u0026gt;\u0026#34;.format(number=number) return HttpResponse(html) str 转换器测试\n# URL urlpatterns = [ ... path(\u0026#39;page/\u0026lt;str:name\u0026gt;\u0026#39;, views.page_welcome), ] # 视图函数 def page_welcome(request, name): html = \u0026#34;\u0026lt;h1\u0026gt;hello {name}!\u0026lt;/h1\u0026gt;\u0026#34;.format(name=name) return HttpResponse(html) slug 转换器测试\n# URL urlpatterns = [ ... path(\u0026#39;page/show/\u0026lt;slug:slug\u0026gt;\u0026#39;, views.page_show) ] # 视图函数 def page_show(request, slug): print(\u0026#39;2\u0026#39;) html = \u0026#34;\u0026lt;h1\u0026gt;title:{slug}\u0026lt;/h1\u0026gt;\u0026#34;.format(slug=slug) return HttpResponse(html) # 注意 使用slug时，如果前方存在str的匹配，会进入str的视图函数，因为slug也是字符串 path 转换器测试\n# URL urlpatterns = [ ... path(\u0026#39;page/path/\u0026lt;path:path\u0026gt;\u0026#39;, views.path_mate) ] # 视图函数 def path_mate(request, path): html = \u0026#34;\u0026lt;h1\u0026gt;path:{path}\u0026lt;/h2\u0026gt;\u0026#34;.format(path=path) return HttpResponse(html) 转换器练习\n# 定义一个路由器的格式为： http:127.0.0.1:8000/整数/操作字符串[add/sub/mul]/整数，从路由中提取数据，做相应的操作后返回给浏览器 # 代码如下： ## URL urlpatterns = [ ... path(\u0026#39;calculator/\u0026lt;int:number1\u0026gt;/\u0026lt;str:method\u0026gt;/\u0026lt;int:number2\u0026gt;\u0026#39;, views.calculator) ] ## 视图函数 def calculator(request, number1, method, number2): if method not in [\u0026#39;add\u0026#39;, \u0026#39;sub\u0026#39;, \u0026#39;mul\u0026#39;]: return HttpResponse(\u0026#34;\u0026lt;h1\u0026gt;method {method} is not support!\u0026lt;/h1\u0026gt;\u0026#34;.format(method=method)) if method == \u0026#39;add\u0026#39;: html = \u0026#34;\u0026lt;h1\u0026gt;{number1} + {number2} = {result}\u0026lt;/h1\u0026gt;\u0026#34;.format(number1=number1, number2=number2, result=number1 + number2) elif method == \u0026#39;sub\u0026#39;: html = \u0026#34;\u0026lt;h1\u0026gt;{number1} - {number2} = {result}\u0026lt;/h1\u0026gt;\u0026#34;.format(number1=number1, number2=number2, result=number1 - number2) else: html = \u0026#34;\u0026lt;h1\u0026gt;{number1} * {number2} = {result}\u0026lt;/h1\u0026gt;\u0026#34;.format(number1=number1, number2=number2, result=number1 * number2) return HttpResponse(html) 4.3 re_path 函数 re_path 函数定义\n在 url 的匹配过程中可以使用正则表达式进行精确匹配。\n# 导入 from django.urls import re_path # 语法 re_path(reg,view,[name=]) # 说明 正则表达式为命名分组模式(?P\u0026lt;name\u0026gt;pattern)；匹配提取参数后用关键字传参方式传递给视图函数 # 注意 使用正则表达式时，需要尽量精准，因此在正则表达式的末尾一定要添加 $ ，否则会导致出现不想要的匹配效果 re_path 函数示例\n# 实现效果：使用 re_path 路由函数匹配数字和字符串，定义路由为 http:127.0.0.1:8000/整数/操作字符串[add/sub/mul]/整数，匹配整数均为两位数的操作 # URL from django.urls import path,re_path urlpatterns = [ ... re_path(r\u0026#39;calculator/(?P\u0026lt;number1\u0026gt;\\d{1,2})/(?P\u0026lt;method\u0026gt;\\w+)/(?P\u0026lt;number2\u0026gt;\\d{1,2})$\u0026#39;, views.calculator_reg), path(\u0026#39;calculator/\u0026lt;int:number1\u0026gt;/\u0026lt;str:method\u0026gt;/\u0026lt;int:number2\u0026gt;\u0026#39;, views.calculator), ] # 视图函数 def calculator(request, number1, method, number2): if method not in [\u0026#39;add\u0026#39;, \u0026#39;sub\u0026#39;, \u0026#39;mul\u0026#39;]: return HttpResponse(\u0026#34;\u0026lt;h1\u0026gt;method {method} is not support!\u0026lt;/h1\u0026gt;\u0026#34;.format(method=method)) if method == \u0026#39;add\u0026#39;: html = \u0026#34;\u0026lt;h1\u0026gt;{number1} + {number2} = {result}\u0026lt;/h1\u0026gt;\u0026#34;.format(number1=number1, number2=number2, result=number1 + number2) elif method == \u0026#39;sub\u0026#39;: html = \u0026#34;\u0026lt;h1\u0026gt;{number1} - {number2} = {result}\u0026lt;/h1\u0026gt;\u0026#34;.format(number1=number1, number2=number2, result=number1 - number2) else: html = \u0026#34;\u0026lt;h1\u0026gt;{number1} * {number2} = {result}\u0026lt;/h1\u0026gt;\u0026#34;.format(number1=number1, number2=number2, result=number1 * number2) return HttpResponse(html) def calculator_reg(request, number1, method, number2): html = \u0026#34;\u0026lt;h1\u0026gt;正则匹配\u0026lt;/h1\u0026gt;\u0026#34; return HttpResponse(html) re_path 练习\n# 实现： # 1.访问地址：http://127.0.0.1:8000/birthday/四位数字/一到两位数字/一到两位数字 # 2.访问地址：http://127.0.0.1:8000/birthday/一到两位数字/一到两位数字/四位数字 # 访问路由页面展示：生日是 xxxx年 xx月 xx日 # URL urlpatterns = [ ... # http://127.0.0.1:8000/birthday/四位数字/一到两位数字/一到两位数字 re_path(\u0026#39;birthday/(?P\u0026lt;year\u0026gt;\\d{4})/(?P\u0026lt;month\u0026gt;\\d{1,2})/(?P\u0026lt;day\u0026gt;\\d{1,2})$\u0026#39;, views.happy_birthday), # http://127.0.0.1:8000/birthday/一到两位数字/一到两位数字/四位数字 re_path(\u0026#39;birthday/(?P\u0026lt;day\u0026gt;\\d{1,2})/(?P\u0026lt;month\u0026gt;\\d{1,2})/(?P\u0026lt;year\u0026gt;\\d{4})$\u0026#39;, views.happy_birthday_2), ] # 视图函数 def happy_birthday(request, year, month, day): html = \u0026#34;happy birthday {year}/{month}/{day}\u0026#34;.format(year=year, month=month, day=day) return HttpResponse(html) def happy_birthday_2(request, day, month, year): html = \u0026#34;happy birthday 2 you : {day}/{month}/{year}\u0026#34;.format(day=day, month=month, year=year) return HttpResponse(html) 5.请求和响应 5.1 HTTP 协议的请求和响应 请求是指浏览器端通过 HTTP 协议发送给服务器端的数据。 响应是指服务器端接收到请求后做相应的处理后再回复给浏览器端的数据。 请求中的方法\n序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中，POST请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档内的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测或判断。 5.2 Django中的请求 请求在Django中实则就是视图函数的第一个参数，即HttpRequest对象。 Django接收到http协议的请求后，会根据请求数据报文创建HttpRequest对象。 HttpRequest对象通过属性描述了请求的所有相关信息。 path_info：url字符串。 methods：字符串，表示HTTP请求方法，常用值：GET、POST。 COOKIES：Python字典，包含所有的cookie，键和值都为字符串。 session：类似于字典的对接，表示当前的会话。 body：字符串，请求体的内容(POST或PUT)。 scheme：请求协议(\u0026lsquo;http/https\u0026rsquo;)。 request.get_full_path()：请求的完整路径。 request.META：请求中的元数据(消息头)。 request.META[\u0026lsquo;REMOTE_ADDR\u0026rsquo;]：客户端IP地址。 5.3 响应 响应状态码的英文为HTTP Status Code，以下为常见的HTTP状态码：\n200，请求成功。 301，永久重定向，资源(网页等)被永久转移到其他URL。 302，临时重定向。 404，请求的资源(网页等)不存在。 500，内部服务器错误。 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用，HTTP状态码共分为五种五种类型：\n分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 5.4 Django中的响应对象 构造函数格式：\nHttpResponse(content=响应体,content_type=响应体数据类型,status=状态码) 作用：\n向客户端浏览器返回响应，同时携带响应体内容。\n常用的 Content-Type 如下：\ntext/html(默认的，html文件) text/plain(纯文本) text/css(css文件) text/javascript(javascript文件) multipart/form-data(文件提交) application/json(json传输) application/xml(xml文件) 在编辑器中，使用不同的响应类即可。\n5.5 GET请求和POST请求 定义：无论是 GET 还是 POST，统一都由视图函数接收请求，通过判断request.method 区分具体的请求动作。\n样例\nif request.method == \u0026#39;GET\u0026#39;: 处理GET请求时的业务逻辑 elif request.method == \u0026#39;POST\u0026#39;： 处理POST请求时的业务逻辑 else: 其他请求业务逻辑 5.5.1 GET处理 GET请求动作，一般用于向服务器获取数据。\n能够产生GET请求的场景：\n浏览器地址栏中输入URL，回车。 \u0026lt;a href=\u0026quot;地址?参数=值\u0026amp;参数=值\u0026quot;\u0026gt;。 form 表单中的 method为 get。 GET请求方式中，如果有数据需要传递给服务器，通常会用查询字符串(Query String)传递：\nURL格式：xxx?参数名1=值1\u0026amp;参数名2=值2\u0026hellip;\n如：http://127.0.0.1:8000/page1?a=100\u0026amp;b=200\n服务器端接收参数，获取客户端请求GET请求提交的数据。\n方法示例：\nrequest.GET[\u0026#39;参数名\u0026#39;] request.GET.get(\u0026#39;参数名\u0026#39;,\u0026#39;默认值\u0026#39;) # 适用于参数有多个值的情况 request.GET.getlist(\u0026#39;参数名\u0026#39;) 5.5.2 POST处理 POST请求动作，一般用于向服务器提交大量/隐私数据。\n客户端通过表单等POST请求将数据传递给服务器端，如：\n\u0026lt;form method=\u0026#39;post\u0026#39;, action=\u0026#39;/login\u0026#39;\u0026gt; 姓名:\u0026lt;input type=\u0026#39;text\u0026#39; name=\u0026#39;username\u0026#39;\u0026gt; \u0026lt;input type=\u0026#39;submit\u0026#39; value=\u0026#39;登陆\u0026#39;\u0026gt; \u0026lt;/form\u0026gt; 使用post方式接收客户端数据。\nrequest.POST[\u0026#39;参数名\u0026#39;] request.POST.get(\u0026#39;参数名\u0026#39;,\u0026#39;\u0026#39;) request.POST.getlist(\u0026#39;参数名\u0026#39;) POST请求需要取消CSRF验证，否则Django会拒绝客户端发来的POST请求，报403响应。\nsettings.py文件中，注释掉django.middleware.csrf.CsrfViewMiddleware。\n6.静态文件 静态文件配置 - settings.py 中\n# 静态文件：CSS、JavaScript、Images ## 静态文件路由配置 STATIC_URL = \u0026#39;/static/\u0026#39; ## 静态文件存储路径配置 STATICFILES_DIRS = (os.path.join(BASE_DIR,\u0026#34;static\u0026#34;),) # 需要在指定的路径下创建static目录，存放静态文件进行访问 7.Django应用及分布式路由 应用在 Django 项目中是一个独立的业务模块，可以包含自己的路由、视图、模板、模型。 7.1 创建应用 用 manage.py 中的子命令 startapp 创建应用文件夹。 在 settings.py 中的 INSTALLED_APPS 列表中配置安装此应用。 7.2 分布式路由 Django 中，主路由配置文件（urls.py）可以不处理用户具体路由，主路由配置文件可以做请求的分发（分布式请求处理），具体的请求可以由各自的应用来处理。\n分布式路由配置步骤：\n主路由中调用 include 函数。\n# 语法：inclued(\u0026#39;app名称.url模块名\u0026#39;) # 作用：用于将当前路由转到各个应用的路由配置文件的 urlpatterns 进行分布式处理 # 示例如下： from django.urls import path, re_path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), ... path(\u0026#39;demo/\u0026#39;, include(\u0026#39;demo.urls\u0026#39;)) ] 应用下配置 urls.py 。\n# 应用下手动创建urls.py 文件，内容结构同主路由完全一致 from django.urls import path from . import views urlpatterns = [ path(\u0026#39;index\u0026#39;, views.index_view) ] 访问页面路由。\n8.模型层及ORM介绍 Django 的 MTV 结构。\n8.1 Django 配置 mysql 8.1.1 依赖安装 安装 mysqlclient [版本 mysqlclient 1.3.13以上]\n安装前需要确认 ubuntu 是否已安装 python3-dev 和 default-libmysqlclient-dev。\npython3-dev # 1.检查安装第三方包的情况 sudo apt list --installed | grep -E \u0026#39;libmysqlclient-dev|python3-dev\u0026#39; # 2.未安装则进行安装 sudo apt install python3-dev default-libmysqlclient-dev 安装 mysqlclient 第三方包。\nsudo pip3 install mysqlclient 8.1.2 Django配置 修改settings.py文件中 DATABASES 配置。\nDATABASES = { \u0026#39;default\u0026#39;:{ \u0026#39;ENGINE\u0026#39;:\u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;HOST\u0026#39;:\u0026#39;host_ip\u0026#39;, \u0026#39;PORT\u0026#39;:3306, \u0026#39;USER\u0026#39;:\u0026#39;username\u0026#39;, \u0026#39;PASSWORD\u0026#39;:\u0026#39;password\u0026#39;, \u0026#39;NAME\u0026#39;:\u0026#39;datanabaseNmae\u0026#39; } } 执行数据库的迁移操作。\npython manage.py migrate 8.1.3 迁移中出现的报错 进行数据库迁移时，报错：SystemError: PY_SSIZE_T_CLEAN macro must be defined for ‘#’ formats，这个是Python3.10不兼容引起的，需要升级用到的 mysqlclient 包到最新版本。\n解决方法：升级mysqlclient到最新版。\n再次进行数据库迁移，正常无报错。\n8.2 模型 8.2.1 模型 模型是一个Python类，它是由django.db.models.Model派生出的子类。 一个模型类代表数据库中的一张表。 模型类中每一个类属性都代表数据库中的一个字段。 模型是数据交互的接口，是表示和操作数据库的方法和方式。 8.2.2 ORM框架 定义：ORM（Object Relational Mapping）即对象关系映射，它是一种程序技术，允许你使用类和对象对数据库进行操作，从而避免通过SQL语句操作数据库。 作用： 简历模型类和表之间的对应关系，允许我们通过面向对象的方式来操作数据库。 根据设计的模型类生成数据库中的表格。 通过简单的配置就可以进行数据库的切换。 优点： 只需要面向对象编程，不需要面向数据库编写代码。 实现了数据模型与数据库的解耦，屏蔽了不同数据库操作上的差异。 8.2.3 ORM框架使用 创建APP应用，创建的应用需要在settings.py中进行注册。\n创建APP应用\npython manage.py startapp bookstore 注册应用\nINSTALLED_APPS = [ ... \u0026#39;bookstore\u0026#39; ] 编写数据库ORM模型。\n在 bookstore 应用的模型文件 models.py 中添加如下代码。\nclass Books(models.Model): title = models.CharField(\u0026#34;书名\u0026#34;, max_length=50, default=\u0026#39;\u0026#39;) price = models.DecimalField(\u0026#34;定价\u0026#34;, max_digits=7, decimal_places=2, default=0.0) 数据库迁移。\n# 生成迁移文件 python manage.py makemigrations # 执行迁移脚本，同步数据库 python manage.py migrate 8.2.4 ORM概念及操作 8.2.4.1 模型类定义 from django.db import models class 模型类名(models.Model): 字段名 = models.字段类型(字段选项) 8.2.4.2 基础字段 BooleanField() 数据库类型：tinyint(1) 编程语言中：使用 True 或者False 来表示值 在数据库中：使用1或0来表示具体的值 CharFild() 数据库类型：varchar 注意：必须要指定 max_length 参数值 DateField() 数据库类型：date 作用：表示日期 参数： auto_now：每次保存对象时，自动设置该字段为当前时间（取值：True/False） auto_now_add：当对象第一次被创建时，自动设置当前时间（取值：True/False） default：设置当前时间值（取值：字符串格式时间，如”2019-6-1“） 以上三个参数只能多选一。 DateTimeField() 数据库类型：datetime(6) 作用：表示日期和时间 参数同 DateField FloatField() 数据库类型：double 编程语言和数据库中都是用小数表示值 DecimalField() 数据库类型：decimal(x,y) 编程语言中：使用小数表示该列的值 在数据库中：使用小数 参数： max_digits：位数总数，包括小数点后的位数，该数必须大于等于decimal_palces decimal_places：小数点后的数字数量 EmailField() 数据库类型：varchar 编程语言和数据库中使用字符串 IntegerField() 数据库类型：int 编程语言和数据库中使用整数 ImageField() 数据库类型：varchar(100) 作用：在数据库中为了保存图片的路径 编程语言和数据库中使用字符串 TextField() 数据库类型：longtext 作用：表示不定长的字符数据 代码示例：\nclass Author(models.Model): name = models.CharField(\u0026#34;姓名\u0026#34;, max_length=11, default=\u0026#39;\u0026#39;) age = models.IntegerField(\u0026#34;年龄\u0026#34;) emal = models.EmailField(\u0026#34;邮箱\u0026#34;) 8.2.4.3 字段选项 字段选项，指定创建的列的额外的信息 允许出现多个字段选项，多个选项之间使用 , 隔开 注：字段选项的官方文档地址（https://docs.djangoproject.com/en/2.2/ref/models/fields/#field-options） primary_key 如果设置为 True，表示该列为主键，如果指定一个字段为主键，则此数据库表不会创建 id 字段。 blank 设置为 True 时，字段可以为空，设置为 False 时，字段为必填项。 null 如果设置为 True，表示该列值允许为空。 默认为 False，如果此选项为False，建议加入 default 选项来设置默认值。 default 设置所在列的默认值，如果字段选项 null = False，建议添加此项。 db_index 如果设置为 True，表示为该列增加索引 unique 如果设置为 True，表示该字段在数据库中的值必须是独一无二的。 db_column 指定列的名称，如果不指定的话则采用属性名作为列名。 verbose_name 设置此字段在 admin 界面上显示的名称。 代码示例：\n# 创建一个属性，表示用户名称，长度40个字符，必须是唯一的，不能为空，添加索引 name = models.CharField(\u0026#34;用户名称\u0026#34;, max_length=40, unique=True, null=False, default=\u0026#39;\u0026#39;, db_index=True) 8.2.4.4 Meta类 使用内部Meta类，来给模型赋予属性，Meta类下有很多内建的类属性，可对模型类做一些控制。 db_table，修改当前模型对应的表名。 unique_together，用于组合多个字段，这些字段组成的值，在数据表中是独一无二的。 注：Meta类官方文档（https://docs.djangoproject.com/zh-hans/2.2/ref/models/options/） 代码示例：\nclass Books(models.Model): title = models.CharField(\u0026#34;书名\u0026#34;, max_length=50, default=\u0026#39;\u0026#39;) price = models.DecimalField(\u0026#34;定价\u0026#34;, max_digits=7, decimal_places=2, default=0.0) info = models.CharField(\u0026#34;描述\u0026#34;, max_length=100, default=\u0026#39;\u0026#39;) class Meta: db_table = \u0026#39;book\u0026#39; # 可以改变当前模型类对应的表名 8.2.4.5 创建数据 Django ORM 使用一种直观的方式把数据库表中的数据表示成 Python 对象。\n创建数据中每一条记录就是创建一个数据对象。\n# 方法一 MyModel.objects.create(属性1=值1,属性2=值2,...) # 成功：返回创建好的实体对象 # 失败：抛出异常 # 方法二 # 创建MyModel 实例对象，并调用 save() 进行保存 obj = MyModel(属性=值) obj.属性 = 值 obj.save() Django提供了一个交互式的操作项目叫 Django Shell，它能够在交互模式用项目工程的代码执行相应的操作。\n注意：项目代码发生变化时，需要重新进入Django Shell。\n启动方式：\npython manage.py shell 代码示例：\nfrom bookstore.models import Books # 方式一 Books.objects.create(title=\u0026#39;大江大河\u0026#39;, price=53.00, info=\u0026#39;大江大河\u0026#39;, pub=\u0026#39;东海工业出版社\u0026#39;, market_price=55.00) # 方式二 bookObj = Books(title=\u0026#39;Django入门教程\u0026#39;, price=53.00, info=\u0026#39;大江大河\u0026#39;, pub=\u0026#39;清华大学出版社\u0026#39;, market_price=55.00) bookObj.info = \u0026#39;Django入门教程\u0026#39; bookObj.save() 数据库中对应出现两条记录。\n8.2.4.6 查询方法 数据库的查询需要使用管理器对象进行。\n通过 MyModel.objects 管理器方法调用查询方法。\n方法 说明 all() 查询全部记录，返回QuerySet查询对象 get() 查询符合条件的单一记录 filter() 查询符合条件的多条记录 exclude() 查询符合条件之外的全部记录 all()方法\n用法：MyModel.objects.all()\n作用：查询 MyModel 实体中所有的数据，等同于 select * from table\n返回值：QuerySet 容器对象，内部存放 MyModel 实例\n代码示例：\nfrom bookstore.models import Books books = Books.objects.all() for book in books: print(\u0026#34;书名\u0026#34;,book.title, \u0026#34;出版社\u0026#34;, book.pub) 也可以在 ORM 模型中定义 __str__ 方法，直接返回表中的信息。\nclass Books(models.Model): title = models.CharField(\u0026#34;书名\u0026#34;, max_length=50, default=\u0026#39;\u0026#39;, unique=True) price = models.DecimalField(\u0026#34;定价\u0026#34;, max_digits=7, decimal_places=2, default=0.0) info = models.CharField(\u0026#34;描述\u0026#34;, max_length=100, default=\u0026#39;\u0026#39;) pub = models.CharField(\u0026#34;出版社\u0026#34;, max_length=100, null=False, default=\u0026#39;\u0026#39;) market_price = models.DecimalField(\u0026#34;图书零售价\u0026#34;, max_digits=7, decimal_places=2, default=0.0) class Meta: # 可以改变当前模型类对应的表名 db_table = \u0026#39;book\u0026#39; def __str__(self): return \u0026#39;%s_%s_%s_%s\u0026#39; % (self.title, self.info, self.pub, self.market_price) values(\u0026lsquo;列1\u0026rsquo;,\u0026lsquo;列2\u0026rsquo;)\n用法：MyModel.objects.values(\u0026hellip;)\n作用：查询部分列的数据并返回，等同于 select 列1，列2 from table\n返回值：QuerySet，返回查询结果容器，容器内存字典，每个字典代表一条数据，格式为：{\u0026lsquo;列1\u0026rsquo;:\u0026lsquo;值1\u0026rsquo;,\u0026lsquo;列2\u0026rsquo;:\u0026lsquo;值2\u0026rsquo;}\n代码示例：\nfrom bookstore.models import Books books = Books.objects.values(\u0026#39;title\u0026#39;,\u0026#39;pub\u0026#39;) print(books) values_list(\u0026lsquo;列1\u0026rsquo;,\u0026lsquo;列2\u0026rsquo;)\n用法：MyModel.objects.values_list(\u0026hellip;)\n作用：返回元组形式的查询结果，等同于select 列1,列2 from table\n返回值：QuerySet 容器对象，内存存放元组。\n会将查询出来的数据封装到元组中，再封装到查询集合 QuerySet 中。\n代码示例：\nbooks = Books.objects.values_list(\u0026#39;title\u0026#39;,\u0026#39;pub\u0026#39;) print(books) order_by()\n用法：MyModel.objects.order_by(\u0026rsquo;-列\u0026rsquo;,\u0026lsquo;列\u0026rsquo;)\n作用：与 all() 方法不同，它会用 SQL 语句的 ORDER BY 子句对查询结果进行根据某个字段选择性的进行排序。\n说明：默认是按照升序排序，降序排序则需要在列前增加 - 表示。\n代码示例：\nfrom bookstore.models import Books books = Books.objects.order_by(\u0026#39;title\u0026#39;) print(books) books = Books.objects.order_by(\u0026#39;-title\u0026#39;) print(books) filter(条件)\n语法：MyModel.objects.filter(属性1=值1,属性2=值2)\n作用：返回包含此条件的全部数据集\n返回值：QuerySet 容器对象，内部存放 MyModel 示例\n说明：当多个属性在一起时为 \u0026ldquo;与\u0026rdquo; 关系\n代码示例：\n# 查询书中出版社为\u0026#34;清华大学出版社\u0026#34;的图书 from bookstore.models import Books books = Books.objects.filter(pub=\u0026#39;清华大学出版社\u0026#39;) print(books) # 查询Author实体中name为王老师并且年龄为28岁的 from bookstore.models import Author authores = Author.objects.all() print(authores) authores = Author.objects.filter(name=\u0026#39;王老师\u0026#39;,age=28) print(authores) exclude(条件)\n语法：MyModel.objects.exclude(条件)\n作用：返回不包含此条件的全部数据集\n代码示例：\nfrom bookstore.models import Author,Books books = Books.objects.exclude(pub=\u0026#39;清华大学出版社\u0026#39;) print(books) get(条件)\n语法：MyModel.objects.get(条件)\n作用：返回满足条件的唯一数据\n说明：该方法只能返回一条数据，查询结果多于一条数据则抛出 Model.MultipleObjectsReturned 异常，查询结果如果没有数据则抛出 Model.DoesNotExist 异常\n代码示例：\n8.2.4.7 查询谓词 定义：做更灵活的条件查询时需要使用查询谓词。\n说明：每一个查询谓词是一个独立的查询功能。\n__exact，等值匹配\n代码示例\nBooks.objects.filter(id__exact=1) # 等同于 select * from author where id = 1 __contains，包含指定值\nBooks.objects.filter(name__contains=\u0026#39;Python\u0026#39;) # 等同于 select * from books where name link \u0026#39;%Python%\u0026#39; __startswith，以 xxx 开始\n__endswith，以 xxx 结束\n__gt，大于指定值\nAuthor.objects.filter(age__gt=50) # 等同于 select * from author where age \u0026gt; 50 __gte，大于等于\n__lt，小于\n__lte，小于等于\n__in，查找数据是否在指定范围内\nAuthor.objects.filter(country__in=[\u0026#39;中国\u0026#39;,\u0026#39;日本\u0026#39;,\u0026#39;韩国\u0026#39;]) # 等同于 select * from author where country in (\u0026#39;中国\u0026#39;,\u0026#39;日本\u0026#39;,\u0026#39;韩国\u0026#39;) __range，查找数据是否在指定的区间范围内\n# 查找年龄在某一区间内的所有作者 Author.objects.filter(age__range=(35,50)) # 等同于 select * from author where age between 35 and 50 8.2.4.8 更新操作 修改单个实体的某些字段值的步骤：\n查，通过 get() 得到要修改的实体对象。 改，通过 对象.属性 的方式修改数据。 保存，通过 对象.save() 保存数据。 代码示例：\n批量更新数据\n直接调用 QuerySet 的 update(属性=值) 实现批量修改 代码示例：\n8.2.4.9 删除操作 单个数据删除的步骤：\n查找查询结果对应的一个数据对象 调用这个数据对象的 delete() 方法实现删除。 代码示例：\n批量删除的步骤：\n查找查询结果集中满足条件的全部 QuerySet 查询集合对象 调用查询集合对象的 delete() 方法实现删除 代码示例：\n伪查询\n通常不会轻易在业务里把数据真正删掉，取而代之的是做伪删除，即在表中添加一个布尔型字段（is_active），默认是True，执行删除时，将欲删除数据的 is_active 字段设置为 False。 注意：用伪删除时，确保显示数据的地方，均添加了 is_active = True 的过滤查询。 8.2.4.10 F对象和Q对象 F对象\n一个F对象代表数据库中某条记录的字段的信息\n作用：\n通常是对数据库中的字段值在不获取的情况下进行操作 用于类属性（字段）之间的比较 语法\nfrom django.db.models import F F(\u0026#39;列名\u0026#39;) 代码示例：\n# 示例1：更新Book示例中所有的零售价涨10元 from django.db.models import F from bookstore.models import Book Book.objects.all().update(market_price=F(\u0026#39;market_price\u0026#39;)+10) # 示例2：对数据库中两个字段的值进行比较，列出那些书的零售价高于定价 from django.db.models import F from bookstore.models import Book Book.objects.filter(market_price__gt=F(\u0026#39;price\u0026#39;)) Q对象\n当在获取查询结果集使用复杂的逻辑或|、逻辑非 ~ 等操作时可以借助Q对象进行操作\n作用：在条件中用来实现除 and(\u0026amp;) 以外的 or(|) 或 not(~) 操作\n语法：\nfrom django.db.models import Q Q(条件1)|(Q条件2) # 条件1成立或条件2成立 Q(条件1)\u0026amp;Q(条件2) # 条件1和条件2同时成立 Q(条件1)\u0026amp;~Q(条件2) # 条件1成立且条件2不成立 代码示例：\n# 示例1：查找清华大学出版社的书或价格低于50的书 Book.objects.filter(Q(pub=\u0026#39;清华大学出版社\u0026#39;)|Q(price__lt=50)) # 示例2：查找不···\t是机械出版社且价格低于50的书 Book.objects.filter(Q(price__lt=50)|~Q(pub=\u0026#39;清华大学出版社\u0026#39;)) 8.2.4.11 聚合查询和原生数据库操作 聚合查询\n聚合查询是指对一个数据表中的一个字段的数据进行部分或全部进行统计查询，查 bookstore 数据表中的全部书的平均价格，查询所有书的总个数等，都要使用聚合查询。\n聚合查询分为：整表聚合、分组聚合\n聚合查询 - 整表聚合\n不带分组的聚合查询是指将全部数据进行集中统计查询。\n聚合函数[需要导入]：\n# 导入方法 from django.db.models import * # 聚合函数：Sum、Avg、Count、Max、Min 语法：MyModel.objects.aggregate(结果变量名=聚合函数(\u0026lsquo;列\u0026rsquo;))\n返回结果：结果变量名和值组成的字典，格式为：{\u0026lsquo;结果变量名\u0026rsquo;:值}\n代码示例：\n聚合查询 - 分组聚合\n分组聚合是指通过计算查询结果中每一个对象所关联的对象集合，从而得出总计值（也可以是平均值或总和），即为查询集的每一项生成聚合。\n语法：QuerySet.annotate(结果变量名=聚合函数(\u0026lsquo;列\u0026rsquo;))\n返回值：QuerySet\n代码示例：\n原生数据库操作\nDjango 页可以支持直接使用SQL语句的方式通信数据库。\n查询：使用 MyModel.objects.raw() 进行数据库的查询操作。\n语法：MyModel.objects.raw(sql语句，拼接参数)\n返回值：RawQuery 集合对象，只支持基础的操作，比如循环\n代码示例：\n原生数据库操作 - SQL注入\n使用原生语句时小心SQL注入。\n定义：用户通过数据上传，将恶意的SQL语句提交给服务器，从而达到攻击效果。\n案例1：用户在搜索图表的SQL传入 1 or 1=1，可以查询出所有的图书数据。\nSQL注入防范\n错误 -\u0026gt; s1 = Book.objects.raw(\u0026lsquo;select * from book where id = %s\u0026rsquo;%(\u0026lsquo;1 or 1=1\u0026rsquo;))\n正确 -\u0026gt; s1 = Book.objects.raw(\u0026lsquo;select * from book where id = %s\u0026rsquo;,[\u0026lsquo;1 or 1=1\u0026rsquo;])\n原生数据库操作 - cursor\n完全跨过模型类操作数据库 - 查询/更新/删除\n导入 cursor 所在的包。\nfrom django.db import connection 用创建 cursor 类的构造函数创建 cursor 对象，再使用 cursor 对象，为保证在出现异常时能释放 cursor 资源，通常使用 with 语句进行创建操作。\nfrom django.db import connection with connection.cursor() as cur: cur.excute(\u0026#39;执行SQL语句\u0026#39;,\u0026#39;拼接参数\u0026#39;) 代码示例：\n原生SQL查询防止SQL注入\n9.admin后台管理 django 提供了比较完善的后台管理数据库的接口，可供开发过程中的调用和测试使用。 django 会搜集所有已注册的模型类，为这些模型类提供数据管理界面，供开发者使用。 9.1 Admin 配置步骤 创建后台管理账号，该账号为后台管理最高权限的账号\npython3 manage.py createsuperuser 使用创建的用户登录管理后台。\n9.2 注册自定义模型类 如果需要将自己定义的模型类也能在 /admin 后台管理中显示和管理，需要将自己的类注册到后台管理界面。\n注册步骤：\n在应用中的 admin.py 中导入注册要管理的模型 models 类，如：\nfrom .models import Book 调用 admin.site.register 方法进行注册，如：\nadmin.site.register(自定义模型类) 代码示例：\n9.3 模型管理器类 作用：为后台管理界面添加便于操作的新功能。\n说明：后台管理器类必须继承自 django.contrib.admin 里的 ModelAdmin类。\n使用方法：\n在 [应用]/admin.py 里定义模型管理类\nclass xxxManager(admin.ModelAdmin): ... 绑定注册模型管理器和模型类\nfrom django.contrib import admin from .models import * admin.site.register(YYYY,xxxManager) # 绑定 YYY模型类与xxxManager管理器类 代码示例1：信息展示\nfrom django.contrib import admin from .models import Book # Register your models here. class BookManager(admin.ModelAdmin): # 列表页显示哪些字段的列 list_display = [\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;pub\u0026#39;, \u0026#39;price\u0026#39;] admin.site.register(Book, BookManager) 代码示例2：信息修改\nfrom django.contrib import admin from .models import Book # Register your models here. # admin.site.register(Book) class BookManager(admin.ModelAdmin): # 列表页显示哪些字段的列 list_display = [\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;pub\u0026#39;, \u0026#39;price\u0026#39;] # 点击那个字段能够进入信息的修改页面 list_display_links = [\u0026#39;title\u0026#39;] admin.site.register(Book, BookManager) 代码示例3：过滤器\nfrom django.contrib import admin from .models import Book # Register your models here. # admin.site.register(Book) class BookManager(admin.ModelAdmin): # 列表页显示哪些字段的列 list_display = [\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;pub\u0026#39;, \u0026#39;price\u0026#39;] # 点击那个字段能够进入信息的修改页面 list_display_links = [\u0026#39;title\u0026#39;] # 添加过滤器 list_filter = [\u0026#39;pub\u0026#39;] admin.site.register(Book, BookManager) 代码示例4：搜索框\nfrom django.contrib import admin from .models import Book # Register your models here. # admin.site.register(Book) class BookManager(admin.ModelAdmin): # 列表页显示哪些字段的列 list_display = [\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;pub\u0026#39;, \u0026#39;price\u0026#39;] # 点击那个字段能够进入信息的修改页面 list_display_links = [\u0026#39;title\u0026#39;] # 添加过滤器 list_filter = [\u0026#39;pub\u0026#39;] # 添加搜索框[模糊查询] search_fields = [\u0026#39;title\u0026#39;] admin.site.register(Book, BookManager) 代码示例5：页面可编辑的字段\nfrom django.contrib import admin from .models import Book # Register your models here. # admin.site.register(Book) class BookManager(admin.ModelAdmin): # 列表页显示哪些字段的列 list_display = [\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;pub\u0026#39;, \u0026#39;price\u0026#39;] # 点击那个字段能够进入信息的修改页面 list_display_links = [\u0026#39;title\u0026#39;] # 添加过滤器 list_filter = [\u0026#39;pub\u0026#39;] # 添加搜索框[模糊查询] search_fields = [\u0026#39;title\u0026#39;] # 添加页面可编辑的字段 list_editable = [\u0026#39;price\u0026#39;] admin.site.register(Book, BookManager) 10.关系映射 在关系型数据库中，通常不会把所有数据都放在同一张表中，不易于扩展，常见的关系映射有：\n一对一映射，如一个身份证对应一个人。 一对多映射，如一个班级可以有多个学生。 多对多映射，如一个学生可以报多个课程，一个课程可以有多个学生学习。 10.1 一对一映射 10.1.1 一对一映射定义 一对一是表示现实事物间存在的一对一的对应关系。如：一个家庭只有一个户主，一个男人有一个妻子，一个人有一个唯一的身份证号等。 10.1.2 一对一映射创建模型 语法：OneToOneField(类名，on_delete=xxx)，on_delete：级联删除。\nclass A(model.Model): ... class B(model.Model): 属性 = models.OneToOneField(A, on_delete=xxx) 特殊字段选项【必须】，on_delete，级联删除。\nDjango中的一对一映射\nmodels.CASCADE 级联删除，Django模拟SQL约束ON DELETE CASCADE的行为，并删除包含ForegnKey的对象。 models.PROTECT 抛出ProtectedError 以组织被引用对象的删除，等同于 mysql 默认的RESTRICT。 SET_NULL 设置 ForeignKey null，需要指定 null=True； SET_DEFAULT 将 ForeignKey 设置为其默认值，必须设置ForeignKey默认值。 代码示例：\nfrom django.db import models # 关系说明：一个人只有一个身份证号码，一个身份证号码对应一个人 # Create your models here. class Person(models.Model): \u0026#34;\u0026#34;\u0026#34; 个人类 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(\u0026#34;姓名\u0026#34;, max_length=11, default=\u0026#39;\u0026#39;, null=False) age = models.IntegerField(\u0026#34;年龄\u0026#34;, default=1) home = models.CharField(\u0026#34;住址\u0026#34;, max_length=256, default=\u0026#39;\u0026#39;) def __str__(self): return \u0026#34;%s_%s_%s\u0026#34; % (self.name, self.age, self.email) class IdCard(models.Model): \u0026#34;\u0026#34;\u0026#34; 身份证件 \u0026#34;\u0026#34;\u0026#34; idCardNUmber = models.CharField(\u0026#34;身份证号码\u0026#34;, max_length=32, null=False) person = models.OneToOneField(Person, on_delete=models.CASCADE) # 一对一属性 10.1.3 一对一映射创建数据 # 无外键的模型类[Person]: person = Person.objects.create(name=\u0026#39;南歌\u0026#39;, age=20, home=\u0026#39;陕西省延安市\u0026#39;) # 有外键的模型类[IdCard] idcard = IdCard.objects.create(idCardNUmber=\u0026#39;xxxx\u0026#39;, person=person) # 也即关联个人的主键值 idcard = IdCard.objects.create(idCardNUmber=\u0026#39;xxxx\u0026#39;, person_id=person_id) 直接关联外键对应的对象。\n数据库查看。\n关联外键对应对象的主键值。\n数据库查看。\n10.1.4 一对一映射查询数据 正向查询：直接通过关联的外键属性查询，则称为正向查询。\n# 通过IdCard查找Person from oto.models import * idCard = IdCard.objects.get(idCardNUmber=\u0026#39;xxxx\u0026#39;) print(\u0026#34;身份证号：{idCardNUmber}的人姓名为：{name}\u0026#34;.format(idCardNUmber=idCard.idCardNUmber, name=idCard.person.name)) 反向查询：没有外键属性的一方，可以调用反向属性查询到关联的另一方。\n注：\n反向关联属性为 实例对象.引用类名（小写），如个人的反向引用为 个人对象.idcard。 当反向引用不存在时，则会触发异常。 # 通过IdCard查找Person from oto.models import * person = Person.objects.get(name=\u0026#39;南歌\u0026#39;) person.idcard.idCardNUmber 反向属性不存在时，触发异常。\n10.2 一对多映射 10.2.1 一对多映射定义 一对多是表现现实事物间存在的一对多的对应关系。如：一个学校有多个班级，一个班级有多个学生，一本图书只能属于一个出版社，一个出版社允许出版多本图书。 一对多需要明确出具体角色，在多表上设置外键。 10.2.2 一对多映射创建模型 语法\n# 当一个A类对象可以关联多个B类对象时 class A(models.Model): ... class B(models.Model): 属性 = models.Foreignkey(\u0026#34;一\u0026#34;的模型类， on_delete=xx) # Fortignkey 必须指定 on_delete模式 代码示例：\nfrom django.db import models # Create your models here. # 关系说明：一个出版社可以有多本图书，一个图书只能对应一个出版社 class Press(models.Model): \u0026#34;\u0026#34;\u0026#34; 出版社 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(\u0026#34;名称\u0026#34;, max_length=128, unique=True) class Book(models.Model): \u0026#34;\u0026#34;\u0026#34; 图书 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(\u0026#34;书名\u0026#34;, max_length=128) press = models.ForeignKey(Press, on_delete=models.CASCADE) 10.2.3 一对多映射创建数据 # 先创建一，再创建多 from otm.models import * press = Press.objects.create(name=\u0026#34;东北大学出版社\u0026#34;) Book.objects.create(name=\u0026#34;C++教程\u0026#34;, press=press) Book.objects.create(name=\u0026#34;Python教程\u0026#34;, press_id=press_id) 10.2.4 一对多映射查询数据 正向查询：直接通过关联的外键属性查询，则称为正向查询。\n# 通过Book查找Press from otm.models import * book = Book.objects.get(name=\u0026#39;Python教程\u0026#39;) print(\u0026#34;{book}的出版社是{name}\u0026#34;.format(book=book.name, name=book.press.name)) 反向查询：没有外键属性的一方，可以调用反向属性查询到关联的另一方。\n# 通过 Press 查找 Book from otm.models import * press = Press.objects.filter(name=\u0026#39;东北大学出版社\u0026#39;) books = press.book_set.all() 10.3 多对多映射 10.3.1 多对多定义 多对多表达对象之间多对多复杂关系，如：每个人都有不同的学校（小学，初中，高中，\u0026hellip;），每个学校都有不同的学生\u0026hellip; Mysql中创建多对多需要依赖第三张表来实现。 Django中无需手动创建第三张表，Django自动完成。 10.3.2 多对多映射创建模型 语法：在关联的两个类中的任意一个类中增加：\n属性 = models.ManyToManyField(MyModel) 代码示例：\n# 关系说明：一个作者可以出版多本图书，一本图书可以被多名坐着同时编写 from django.db import models # Create your models here. class Author(models.Model): name = models.CharField(\u0026#34;作者\u0026#34;, max_length=128) class Book(models.Model): name = models.CharField(\u0026#34;书名\u0026#34;, max_length=128) authors = models.ManyToManyField(Author) 10.3.3 多对多映射创建数据 # 方案一：先创建author再关联book author1 = Author.objects.create(name=\u0026#34;南歌\u0026#34;) author2 = Author.objects.create(name=\u0026#34;EuanSu\u0026#34;) ## 南歌和EuanSu同时写了一本《Django教程》 book = author1.book_set.create(name=\u0026#34;Django教程\u0026#34;) author2.book_set.add(book) # 方案二：先创建book再关联author book = Book.objects.create(name=\u0026#34;Python教程\u0026#34;) ## 南歌和EuanSu都参与了《Python教程》的编写 author = book.authors.create(name=\u0026#34;南歌\u0026#34;) book.authors.add(author) 10.3.4 多对多映射查询数据 正向查询：直接通过关联的外键属性查询，则称为正向查询。\n# 通过Book查询对应所有的 Author，此时多对多属性等价于objects ## 获取 book 对应的所有author信息 book.authors.all() ## 获取book对应作者中名字为南歌的author book.authors.filter(name=\u0026#34;南歌\u0026#34;) 反向查询：没有外键属性的一方，可以调用反向属性查询到关联的另一方。\n# 通过Author查询对应所有的book，利用反向属性book_set author.book_set.all() author.book_set.filter(name=\u0026#34;Django教程\u0026#34;) 11.Cookies和Session 11.1 会话 从打开浏览器访问一个网站，到关闭浏览器结束此次访问，称之为一次会话。 HTTP协议是无状态的，导致会话状态难以保持。 Cookies和Session就是为了保持会话状态而诞生的两个存储技术。 11.2 Cookies 11.2.1 Cookies定义 Cookies是保存再客户端浏览器上的存储空间。\nChrome 浏览器可能通过开发者工具的 Application \u0026raquo; Storage \u0026raquo; Cookies 查看和操作浏览器端所有的Cookies值。\n火狐浏览器 通过开发者工具的 存储 \u0026raquo; Cookie 查看。\n11.2.2 Cookies特点 Cookies 在浏览器上是以键值对的形式进行存储到，键和值都是以ASCII字符串的形式存储（不能是中文字符串）。 存储的数据带有生命周期。 Cookies 中的数据是按照域存储隔离的，不同的域之间无法访问。 Cookie 的内部数据会在每次访问此网址时都会携带到服务器端，如果Cookies过大会降低响应速度。 11.2.3 Cookies的使用 # 设置/修改Cookie HttpResponse.set_cookie(key,value=\u0026#39;\u0026#39;,max_age=None,expires=None) ## key：Cookie的名字 ## value：Cookie的值 ## max_age：Cookie存储时间，秒为单位 ## expires：具体的过期时间 ## 当不指定 max_age 和 expires 时，关闭浏览器此时数据失效 # 删除/获取Cookie HttpResponse.delete_cookie(key) ## 删除指定的key的Cookie，如果key不存在则什么也不发生 # 获取Cookies request.COOKIES.get(\u0026#39;Cookie名\u0026#39;,\u0026#39;默认值\u0026#39;) ## 通过request.COOKIES 绑定的字典（dict）获取客户端的COOKIES数据 代码示例\n# 浏览器设置一个名为uname的cookie，值是euansu，过期时间为10分钟的cookie from django.shortcuts import render from django.http import HttpResponse # Create your views here. def set_cookies(request): response = HttpResponse(\u0026#34;set cookies\u0026#34;) response.set_cookie(\u0026#34;uname\u0026#34;, \u0026#34;euansu\u0026#34;, 600) return response 代码示例\n# 浏览器设置一个键为 my_cookie，值为123，过期时间为1个小时的cookie def set_cookies_new(request): response = HttpResponse(\u0026#34;set cookies\u0026#34;) response.set_cookie(\u0026#34;my_cookie\u0026#34;, \u0026#34;123\u0026#34;, 3600) return response # 浏览器修改 my_cookie的值为123，过期时间为2个小时 def update_cookies(request): response = HttpResponse(\u0026#34;update cookies\u0026#34;) response.set_cookie(\u0026#34;my_cookie\u0026#34;, \u0026#34;456\u0026#34;, 7200) return response 浏览器设置 cookie\n浏览器修改 cookie。\n代码示例\n# 浏览器删除Cookies def delete_cookies(request): response = HttpResponse(\u0026#34;delete cookies\u0026#34;) response.delete_cookie(\u0026#34;my_cookie\u0026#34;) return response 代码示例\n# 获取Cookies def get_cookies(request): values = request.COOKIES.get(\u0026#34;my_cookie\u0026#34;, \u0026#34;my_cookie\u0026#34;) return HttpResponse(\u0026#34;my_cookie value is {my_cookie}\u0026#34;.format(my_cookie=values)) 11.3 session 11.3.1 session定义 session 是在服务器上开辟一段空间用于保留浏览器和服务器交互时的重要数据。\n实现方式：\n使用 session 需要在浏览器客户端启动 cookie，且在cookie中存储sessionid。 每个客户端都可以在服务器端有一个独立的session。 注意：不同的请求者之间不会共享这个数据，与请求者一一对应。 11.3.2 session初始配置 settings.py 中配置 session。\n向 INSTALLED_APPS 列表中添加：\nINSTALLED_APPS = [ ... # 启用 sessions 应用 \u0026#39;django.contrib.sessions\u0026#39;, ] 向 MIDDLEWARE 列表中添加：\nMIDDLEWARE = [ ... # 启用 session 中间件 \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, ] 11.3.3 session的使用 session 对象是一个类似于字典的sessionstore类型的对象，可以用类拟于字典的方式进行操作。\nsession 能够存储如字符串、整型、字典、列表等。\n保存 session 的值到服务器。\nrequest.session[\u0026#39;key\u0026#39;] = value 获取 session 的值。\nvalue = request.session[\u0026#39;key\u0026#39;] vakue = request.session.get(\u0026#39;key\u0026#39;, 默认值) 删除 session。\ndel request.session[\u0026#39;key\u0026#39;] 代码示例\n# 设置session def set_session(request): request.session[\u0026#39;uname\u0026#39;] = \u0026#39;euansu\u0026#39; return HttpResponse(\u0026#34;set session is ok!\u0026#34;) 代码示例\n# 获取session def get_session(request): value = request.session.get(\u0026#34;uname\u0026#34;, \u0026#34;\u0026#34;) return HttpResponse(\u0026#34;session unmae values is {value}\u0026#34;.format(value=value)) 代码示例\n# 修改session def update_session(request): request.session[\u0026#39;uname\u0026#39;] = \u0026#39;南歌\u0026#39; return HttpResponse(\u0026#34;update session is ok!\u0026#34;) 代码示例\n# 删除session def delete_session(request): del request.session[\u0026#34;uname\u0026#34;] return HttpResponse(\u0026#34;delete session is ok!\u0026#34;) 11.3.4 session相关配置项 SESSION_COOKIE_AGE\n作用：指定 sessionid 在 cookies 中的保存时长（默认是两周），如下：\nSESSION_COOKIE_AGE = 60*60*24*7*2 SESSION_EXPIRE_AT_BROWSER_CLOSE = True\n设置只要浏览器关闭时，session就失效（默认为False）\n注意：Django 中的session数据存储在数据库中，所以使用session前需要确保已经执行migrate。\n11.3.5 Django session的问题 django_session 表是单表设计，且该表数据量持续增持（浏览器故意删掉sessionid\u0026amp;过期数据未删除）。 可以每晚执行 python3 manage.py clearsessions，该命令可以删除已过期的session数据。 11.3.6 Cookies 和 session 对比 12.缓存 12.1 缓存的定义 定义：缓存是一类可以更快的读取数据的介质统称，也指其他可以加快数据读取的存储方式，一般用来存储临时数据，常用介质的是读取速度很快的内存。\n意义：视图渲染有一定成本，数据库的频繁查询过高，所以对于低频变动的页面可以考虑使用缓存技术，减少实际渲染次数，用户拿到响应的时间成本会更低。\nDjango 缓存的实现方法\n# Django 官网 # https://docs.djangoproject.com/en/5.0/topics/cache/ # given a URL, try finding that page in the cache if the page is in the cache: return the cached page else: generate the page save the generated page in the cache (for next time) return the generated page 缓存场景：\n博客列表页 电商商品详情页 场景特点：缓存的地方，数据变动频率较少。\n12.2 缓存的配置 12.2.1 Mysql缓存 将缓存的数据存储在数据库中。\n说明：尽管存储介质没有更换，但是当把一次负责查询的结果直接存储到表里，比如多个条件的过滤查询结果，可避免重复进行复杂的查询，提升效率。\n在 settings.py 中添加 CACHES 配置块。\nCACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django.core.cache.backends.db.DatabaseCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;my_cache_table\u0026#34;, # 缓存表的名称 \u0026#34;TIMEOUT\u0026#34;: 300, #缓存的保存时间，单位秒，默认值是300 \u0026#34;POTIONS\u0026#34;:{ \u0026#34;MAX_ENTRIES\u0026#34;: 300, # 缓存最大的数据条数 \u0026#34;CULL_FREQUENCY\u0026#34;: 2 # 缓存条数达到最大值时，删除 1/CULL_FREQUENCY 的缓存数据 } } } 创建缓存表。\npython3 manage.py createcachetable 查看数据库。\n使用 mysql 进行缓存，会将数据存储在指定的 mysql 表中。\n12.2.2 Redis缓存 Redis是一个内存数据库，可用于缓存。\n在 settings.py 中添加如下 CACHES 块。\nCACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django.core.cache.backends.redis.RedisCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;redis://username:password@127.0.0.1:6379\u0026#34;, # username、password需要看redis是否启用身份认证，如未启用，这里则不需要配置。 # \u0026#34;LOCATION\u0026#34;: [ # \u0026#34;redis://127.0.0.1:6379\u0026#34;, # leader # \u0026#34;redis://127.0.0.1:6378\u0026#34;, # read-replica 1 # \u0026#34;redis://127.0.0.1:6377\u0026#34;, # read-replica 2 # ], # 如果有多个redis服务器时，这样配置即可 } } 12.2.3 本地内存缓存 数据缓存到服务器内存中，如果配置文件中没有指定其他缓存，那么这是默认的缓存。如果你想获得内存缓存的速度优势，但又不具备运行 Memcached 的能力，可以考虑使用本地内存缓存后端。这个缓存是每进程所有（见下文）和线程安全的。\n在 settings.py 中添加如下 CACHES 块。\n# 说明：如下仅供测试，建议将数据存储到内存数据库中，如redis # 每个进程都会有自己的私有缓存实例，这意味着不可能进行跨进程缓存，也即本地内存缓存的内存效率不是特别高，所以对于生产环境来说，它可能不是一个好的选择。对于开发来说是不错的选择。 CACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django.core.cache.backends.locmem.LocMemCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;unique_snowflake\u0026#34;, } } 12.2.4 文件系统缓存 将缓存的数据存储到本地文件中。\n在 settings.py 中添加如下 CACHES 块。\nCACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django.core.cache.backends.filebased.FileBasedCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;/home/euansu/tmp\u0026#34;, # 这个是文件夹的路径 # \u0026#34;LOCATION\u0026#34;: \u0026#34;c:\\test\\cache\u0026#34;, # windows下示例 } } 使用文件系统缓存，会在配置的目录下生成对应的缓存文件。\n12.3 整体缓存策略 整体缓存这里指的是直接缓存一个视图函数全部的结果，与下部分的局部缓存形成对照。\n12.3.1 视图函数 from django.views.decorators.cache import cache_page @cache_page(30) def my_view(request): ... 代码示例\nfrom django.shortcuts import render from django.views.decorators.cache import cache_page from django.http import HttpResponse # Create your views here. from datetime import datetime import pytz @cache_page(30) def mysql_cache(request): \u0026#34;\u0026#34;\u0026#34; MysqlCache :param request: :return: \u0026#34;\u0026#34;\u0026#34; target_timezone = pytz.timezone(\u0026#39;Asia/Shanghai\u0026#39;) current_time = datetime.now() current_time_shanghai = current_time.replace(tzinfo=pytz.utc).astimezone(target_timezone) time_string = current_time_shanghai.strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) return HttpResponse(time_string) 12.3.2 路由函数 from django.views.decorators.cache import cache_page urlpatterns = [ path(\u0026#39;foo/\u0026#39;, cache_page(60)(my_view)), ] 代码示例\nfrom django.urls import path from django.views.decorators.cache import cache_page from . import views urlpatterns = [ path(\u0026#34;mysql_cache/\u0026#34;, cache_page(60)(views.mysql_cache)), ] 12.4 局部缓存策略 视图函数局部耗时较多，但视图函数其他区域并不耗时。\n12.4.1 使用场景 使用场景\n# 局部耗时较多，但视图函数其他区域并不耗时 from django.shortcuts import render def index(request): # 时间复杂度极高的渲染 book_list = Book.objects.all() # 假设此处耗时2s return render(request,\u0026#39;idnex.html\u0026#39;,locals()) 12.4.2 局部缓存的使用 # 先引入cache对象 ## 方式一：使用caches[\u0026#39;CACHE配置key\u0026#39;]导入具体对象 from django.core.cache import cache cache1 = caches[\u0026#39;default\u0026#39;] cache2 = caches[\u0026#39;custom\u0026#39;] ## 方式二： from django.core.cache import cache # 相当于直接引入 CACHES 配置项中的\u0026#39;default\u0026#39;项 12.4.3 局部缓存的方法 cache.set(key, value, timeout)，存储缓存\nkey：缓存的key，字符串类型\rvalue：Python对象\rtimeout：缓存存储时间（s），默认为CACHES中的TIMEOUT值\r返回值：None cache.get(key)，获取缓存\nkey：缓存的key\r返回值：为key的具体值，如果没有数据，则返回None cache.add(key, value)，存储缓存，只在key不存在时生效\n返回值：True[存储成功] or False[存储失败] cache.get_or_set(key, value, timeout)，如果未获取到数据，则执行set操作\n返回值：value cache.set_many(dict, timeout)，批量存储缓存\ndict：key和value的字典\rtimout：存储的时间（s）\r返回值：插入不成功的key的数组 cache.get_many(key_list)，批量获取缓存数据。\nkey_list：包含key的数组\r返回值：渠道的key和value的字典 cache.delete(key)，删除key的缓存数据。\n返回值：None cache.delete_many(key_list)，批量删除。\n返回值：None 12.4.4 局部缓存测试 代码示例：\n# 设置cache from django.core.cache import cache cache.set(\u0026#34;uname\u0026#34;, \u0026#34;euansu\u0026#34;, 300) cache.get(\u0026#34;uname\u0026#34;) 数据库中出现对应cache记录。\n# 修改cache cache.set(\u0026#34;uname\u0026#34;, \u0026#34;nange\u0026#34;, 300) cache.get(\u0026#34;uname\u0026#34;) # 删除cache cache.delete(\u0026#34;uname\u0026#34;) cache.get(\u0026#34;uname\u0026#34;) 查询数据库，对应的缓存消失\n12.5 浏览器缓存策略 浏览器也具备缓存技术，对于浏览器来说，每次向服务器发出请求都是耗时的操作，如果本身浏览器内部就具备当前 url 的内容，则一定时间内可以不必给服务器发消息，从而提升网页体验，降低服务器的请求压力。\n12.5.1 浏览器缓存-强缓存 不会向服务器发送请求，直接从缓存中读取资源。\n服务器和浏览器之间的请求，通过如下两个响应头进行沟通。\n响应头 - Expires\n定义：缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点\r样例：Expires:Thu, 02 Apr 2030 05:15:08 GMT 响应头 - Cache-Control\n在HTTP/1.1中，Cache-Control主要用于控制网页缓存，比如当 Cache-Control:max-age=120 代表请求创建后的120秒，缓存失败\r说明：目前服务器都会带着这两个头同时响应给浏览器，浏览器优先使用 Cache-Control 例如如下请求，浏览器中显示已缓存。\n刷新页面，但浏览器中仅有一次请求。\n查看请求响应，发现返回的响应中有 Cache-Control 和 Expires 两个响应头。\n这里的 max-age=60 是通过 cache-page 实现的。\n修改 cache_page 的参数，响应头中的 max-age 也发生变化。\n12.5.2 浏览器缓存-协商缓存 图片、静态文件等这类比较费带宽且不易变化的数据，浏览器会跟服务器协商，确认当前的缓存是否可用，如果可用，服务器不需要返回数据，浏览器继续使用原来缓存的数据，如果文件不可用，则返回最新的数据。\nLast-Modified 响应头和 If-Modified-Since 请求头。\n说明：\nLast-modified 为文件的最近修改时间，浏览器第一次请求静态文件时，服务器第一次请求静态文件时，服务器如果返回Last-Modified响应头，则代表该资源为需要协商的缓存。 当缓存到期后，浏览器将获取到的 Last-Modified 值作为请求头 If-Modified-Since 的值，与服务器发请求协商，服务器端返回304响应码[响应体为空]，代表缓存继续使用，200响应码代表缓存不可用[响应体为最新资源]。 代码示例\nfrom django.http import HttpResponse from django.utils import timezone def last_modified(request): \u0026#34;\u0026#34;\u0026#34; 测试last-modified请求头 :param request: :return: \u0026#34;\u0026#34;\u0026#34; last_modified_time = timezone.now() # 检查 If-Modified-Since 头 if request.META.get(\u0026#39;HTTP_IF_MODIFIED_SINCE\u0026#39;): # 如果资源没有发生变化，返回 304 Not Modified return HttpResponse(status=304) # 如果资源发生了变化，设置 Last-Modified 响应头 response = HttpResponse(\u0026#34;Your content here\u0026#34;) response[\u0026#39;Last-Modified\u0026#39;] = last_modified_time.strftime(\u0026#39;%a, %d %b %Y %H:%M:%S GMT\u0026#39;) return response ETag 响应头和 If-None-Match 请求头。\n说明：\nETag时服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），只要资源有变化，ETag就会重新生成。 缓存到期后，浏览器将ETag响应头的值作为If-None-Match请求头的值，给服务器发请求协商，服务器接到请求头后，比对文件标识，不一致则认为资源不可用，返回200响应码[响应体为最新资源]，可用则返回304响应码。 代码示例\nfrom django.http import HttpResponse import hashlib def etag_func(request): # 获取或计算资源的内容（假设这里是一个字符串） resource_content = \u0026#34;Your content here\u0026#34; # 计算 ETag（使用 MD5 散列作为示例，你可以根据需要选择其他方法） etag = hashlib.md5(resource_content.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() # 检查 If-None-Match 头 if request.META.get(\u0026#39;HTTP_IF_NONE_MATCH\u0026#39;) == etag: # 如果资源没有发生变化，返回 304 Not Modified return HttpResponse(status=304) # 如果资源发生了变化，设置 ETag 响应头 response = HttpResponse(resource_content) response[\u0026#39;ETag\u0026#39;] = etag return response 首次访问返回200。\n再次请求，响应变为304。\n13.中间件 13.1 中间件的定义 中间件是Django请求/响应处理的钩子框架。它是一个轻量级的、低级的“插件”系统，用于全局改变Django的输入或输出。 中间件以类的形式体现。 每个中间件组件负责做一些特定的功能。例如，Django包含一个中间件组件AuthenticationMiddleware，它使用会话将用户与请求关联起来。 13.2 编写中间件 中间件类必须继承自django.utils.deprecation.MiddlewareMixin类。 中间件类必须实现下列五个方法中的一个或多个： process_request(self, request)，执行路由之前被调用，在每个请求上调用，返回None或HttpResponse对象。 process_view(self, request, callback, callback_args, callback_kwargs)，调用视图之前被调用，在每个请求上调用，返回None或HttpResponse对象。 process_response(self, request, response)，所有响应返回浏览器被调用，在每个请求上调用，返回HttpResponse对象。 process_exception(self, request, exception)，当处理过程中抛出异常时调用，返回一个HttpResponse对象。 process_template_response(self, request, response)，在视图函数执行完毕且视图返回的对象中包含render方法时被调用，该方法需要返回实现了render方法的响应对象。 注：中间件中的大多数方法在返回None时表示忽略当前操作进入下一项事件，当返回HttpResponse对象时表示此请求结束，直接返回给客户端。\n13.3 注册中间件 settings.py中需要注册一下自定义的中间件\nMIDDLEWARE = [ ... ] 注意：配置为数组，中间件被调用时以“先上到下”再“由下到上”的顺序调用。\n13.4 中间件的使用 首先是创建中间件的目录以及文件，如下图所示。\n编写中间件的代码。\nfrom django.utils.deprecation import MiddlewareMixin class customMiddleware(MiddlewareMixin): \u0026#34;\u0026#34;\u0026#34; 自定义中间件 \u0026#34;\u0026#34;\u0026#34; def process_request(self, request): \u0026#34;\u0026#34;\u0026#34; 请求达到路由前被调用 :param request: :return: \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;customMiddleware process_request 被调用\u0026#34;) def process_view(self, request, callback, callback_args, callback_kwargs): \u0026#34;\u0026#34;\u0026#34; 调用视图函数前被调用 :param request: :param callback: :param callback_args: :param callback_kwargs: :return: \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;customMiddleware process_view 被调用\u0026#34;) def process_response(self, request, response): \u0026#34;\u0026#34;\u0026#34; 响应返回前被调用 :param request: :param response: :return: \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;customMiddleware process_response 被调用\u0026#34;) return response 注册中间件。\n# settings.py MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, # 注册中间件 \u0026#39;middleware.custommiddleware.customMiddleware\u0026#39;, ] 中间件调用测试。\n中间件被调用时以“先上到下”再“由下到上”的顺序调用。\n增加一个新的中间件“customMiddleware2”。\nclass customMiddleware2(MiddlewareMixin): \u0026#34;\u0026#34;\u0026#34; 自定义中间件 \u0026#34;\u0026#34;\u0026#34; def process_request(self, request): \u0026#34;\u0026#34;\u0026#34; 请求达到路由前被调用 :param request: :return: \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;customMiddleware2 process_request 被调用\u0026#34;) def process_view(self, request, callback, callback_args, callback_kwargs): \u0026#34;\u0026#34;\u0026#34; 调用视图函数前被调用 :param request: :param callback: :param callback_args: :param callback_kwargs: :return: \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;customMiddleware2 process_view 被调用\u0026#34;) def process_response(self, request, response): \u0026#34;\u0026#34;\u0026#34; 响应返回前被调用 :param request: :param response: :return: \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;customMiddleware2 process_response 被调用\u0026#34;) return response 注册中间件。\nMIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, \u0026#39;middleware.custommiddleware.customMiddleware\u0026#39;, \u0026#39;middleware.custommiddleware.customMiddleware2\u0026#39;, ] 调用测试。\n14.Django内建用户系统 14.1 Django中的用户认证 Django带有一个用户认证系统系统，它处理用户用户账号、组、权限以及基于cookie的用户会话。 用户可以直接使用Django自带的用户表。 官方文档：https://docs.djangoproject.com/zh-hans/2.2/topics/auth/ 14.2 用户系统表的基本字段 模型类位置 from django.contrib.auth.models import User\n字段名 含义 username 用户名 password 密码 email 邮箱 first_name 名 last_name 姓 is_superuser 是否管理员账号 is_staff 是否可以访问admin管理界面 is_active 是否是活跃用户，默认为True，一般不删除用户，而是将用户的is_active设为False last_login 上一次登录时间 date_joined 用户创建的时间 14.3 用户系统的基本模型操作 创建普通用户 create_user：\nfrom django.contrib.auth.models import User user = User.objects.create_user(username=\u0026#39;用户名\u0026#39;, password=\u0026#39;密码\u0026#39;, email=\u0026#39;邮箱\u0026#39;, ...) 创建超级用户 create_superuser：\nfrom django.contrib.auth.models import User user = User.objects.create_superuser(username=\u0026#39;用户名\u0026#39;, password=\u0026#39;密码\u0026#39;, email=\u0026#39;邮箱\u0026#39;, ...) 删除用户：\nfrom django.contrib.auth.models import User try: user = User.objects.get(username=\u0026#39;用户名\u0026#39;) user.is_active = False user.save() print(\u0026#34;删除普通用户成功\u0026#34;) except: print(\u0026#34;删除普通用户失败\u0026#34;) 校验密码：\n# 说明：如果用户名密码校验成功则返回对应的User对象，否则返回None from django.contrib.auth import authenticate user = authenticate(username=username, password=password) 修改密码：\nfrom django.contrib.auth.models import User try: user = User.objects.get(username=\u0026#39;用户名\u0026#39;) user.set_password(\u0026#39;123456\u0026#39;) user.save() print(\u0026#34;修改密码成功\u0026#34;) except: print(\u0026#34;修改密码失败\u0026#34;) 登录状态保持：\nfrom django.contrib.auth import login,authenticate def login_view(request): user = authenticate(username=\u0026#39;用户名\u0026#39;, password=\u0026#39;密码\u0026#39;) login(request, user) 登录状态校验：\nfrom django.contrib.auth.decorators import login_required @login_required def index_view(request): # 该视图必须为用户登录状态下才可以访问 # 当前登录用户可以通过request.user获取 login_user = request.user ... 用户注销登录：\nfrom django.contrib.auth import logout def logout_view(request): logout(request) 代码示例：\n创建 templates 目录，放置 html 页面。\n编写对应的template页面。\nregister.html，用户注册页。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Register\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;{% url \u0026#39;register_page\u0026#39; %}\u0026#34;\u0026gt; {% csrf_token %} {{ form }} \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; login.html，用户登录页。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Login\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;{% url \u0026#39;login\u0026#39; %}\u0026#34;\u0026gt; {% csrf_token %} {{ form }} \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; homepage.html，首页。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;homepage\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;{% url \u0026#39;logout\u0026#39; %}\u0026#34;\u0026gt; {% csrf_token %} 欢迎访问项目 \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;注销用户\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 编写对应的视图函数。\nfrom django.shortcuts import render from django.contrib.auth.models import User from django.http import HttpResponseRedirect, HttpResponse from django.contrib.auth import authenticate, login, logout from .forms import loginForm, registerForm from django.contrib.auth.decorators import login_required # Create your views here. def login_page(request): \u0026#34;\u0026#34;\u0026#34; 项目登录面 :param request: :return: \u0026#34;\u0026#34;\u0026#34; # return render(request, \u0026#39;hello.html\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: form = loginForm(request.POST) if form.is_valid(): # 处理表单提交逻辑，可以访问 form.cleaned_data 获取表单字段的值 username = form.cleaned_data[\u0026#39;username\u0026#39;] password = form.cleaned_data[\u0026#39;password\u0026#39;] if not username or not password: return HttpResponse(\u0026#34;请输入正确的参数\u0026#34;) # 校验密码 user = authenticate(username=username, password=password) print(\u0026#39;校验用户\u0026#39;) print(user) if not user: return HttpResponse(\u0026#34;用户名或密码错误\u0026#34;) else: # 记录会话状态 login(request, user) return HttpResponseRedirect(\u0026#39;/homepage\u0026#39;) else: form = loginForm() return render(request, \u0026#39;login.html\u0026#39;, {\u0026#39;form\u0026#39;: form}) def register_page(request): \u0026#34;\u0026#34;\u0026#34; 项目注册页面 :param request: :return: \u0026#34;\u0026#34;\u0026#34; # return render(request, \u0026#39;hello.html\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: form = registerForm(request.POST) if form.is_valid(): # 处理表单提交逻辑，可以访问 form.cleaned_data 获取表单字段的值 username = form.cleaned_data[\u0026#39;username\u0026#39;] password1 = form.cleaned_data[\u0026#39;password1\u0026#39;] password2 = form.cleaned_data[\u0026#39;password2\u0026#39;] if not username or not password1 or not password2: return HttpResponse(\u0026#34;请传入正确的参数\u0026#34;) # 进行注册操作 try: if password1 != password2: return HttpResponse(\u0026#34;两次输入的密码不一致\u0026#34;) # 创建用户 user = User.objects.create_user(username=username, password=password1) # 注册成功 return HttpResponseRedirect(\u0026#39;/login\u0026#39;) except Exception as e: # 注册失败 print(e) return HttpResponse(\u0026#34;注册用户失败，请联系管理员进行处理\u0026#34;) else: form = registerForm() return render(request, \u0026#39;register.html\u0026#39;, {\u0026#39;form\u0026#39;: form}) def logout_func(request): \u0026#34;\u0026#34;\u0026#34; 注销登录 :param request: :return: \u0026#34;\u0026#34;\u0026#34; logout(request) return HttpResponseRedirect(\u0026#39;/login\u0026#39;) 编写对应的路由函数。\nfrom django.urls import path, re_path from . import views urlpatterns = [ path(\u0026#34;\u0026#34;, views.login_page, name=\u0026#39;login\u0026#39;), path(\u0026#34;register/\u0026#34;, views.register_page, name=\u0026#39;register_page\u0026#39;), path(\u0026#34;logout/\u0026#34;, views.logout_func, name=\u0026#39;logout\u0026#39;) ] 配置项目默认的登录页面。\n# settings.py # 配置了登录地址，当访问到需要登录的页面时，如果此时用户未登录，则跳转至登录页面 LOGIN_URL = \u0026#39;/login\u0026#39; 页面调用测试。\n注册页面输入用户名，密码，确认密码后点击submit进行登录。\n成功注册后，跳转至login页面，输入刚才注册的用户名和密码，点击submit进行登录。\n登录成功，跳转至项目首页。\n再打开一个标签页，注销登录后，项目首页无法访问。\n14.4 用户系统的扩展字段 通过建立新表，跟内建表做一对一映射。 继承内建的抽象User模型类。 14.4.1 继承内部抽象类 步骤：\n添加新的应用。 定义模型类，集成AbstractUser。 settings.py中指明AUTH_USER_MODEL=\u0026lsquo;应用名.类名\u0026rsquo;。 注：该操作需要在第一次migrate之前进行，否则会报如下的错误。\n代码测试：\n添加新的应用。\npython3 manage.py startapp useradmin 定义模型类，集成AbstractUser。\nfrom django.db import models from django.contrib.auth.models import AbstractUser # Create your models here. class UserInfo(AbstractUser): phone = models.CharField(max_length=11, default=\u0026#39;\u0026#39;) settings.py中指明AUTH_USER_MODEL=\u0026lsquo;应用名.类名\u0026rsquo;。\nAUTH_USER_MODEL = \u0026#39;useradmin.UserInfo\u0026#39; 执行代码迁移。\npython3 manage.py makemigrations python3 manage.py migrate 迁移成功后，查看数据库，auth_user表消失，出现了一个useradmin_userinfo的表。\n创建新用户测试。\nfrom django.contrib.auth.models import User user = User.objects.create_user(username=\u0026#39;euansu\u0026#39;, password=\u0026#39;euansu\u0026#39;, email=\u0026#39;euansu@euansu.cn\u0026#39;, phone=13000000000) 查看数据库\n使用新创建的用户登录刚才的项目，可以正常登录。\n15.文件上传 15.1 定义\u0026amp;场景 定义：用户可以通过浏览器将图片等文件上传至网站。 场景： 用户上传头像。 上传流程性的文档[pdf，txt等] 15.2 上传规范-前端[html] 文件上传必须为POST提交方式 表单 \u0026lt;form\u0026gt; 中文件上传时必须带有 enctype=\u0026quot;multipart/form-data\u0026quot; 时才会包含文件内容数据。 表单中用 \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;xxx\u0026quot;\u0026gt; 标签上传文件。 15.3 上传规范-后端[Django] 视图函数中，用request.FILES取文件框的内容 file=request.FILES[\u0026lsquo;xxx\u0026rsquo;] 说明：\nFILE的key对应页面中file框的name值。 file绑定文件流对象。 file.name文件名。 file.file文件的字节流数据。 配置文件的访问路径和存储路径：\n在settings.py中设置MEDIA相关配置，Django把用户上传的文件统称为media资源，需要与静态资源static进行区分。\n# file:settings.py MEDIA_URL = \u0026#39;/media/\u0026#39; MEDIA_ROOT = os.path.join(BASE_DIR, \u0026#39;media\u0026#39;) MEDIA_URL 和 MEDIA_ROOT 需要手动绑定。\n方法：主路由中添加路由。\n# 说明：等价于做了MEDIA_URL开头的路由，Django接到该特征请求后去MEDIA_ROOT路径查找资源 from django.conf impot settings from django.conf.urls.static import static urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 文件写入方案1：传统的open方式\n@csrf_exempt def file_upload(request): if request.method == \u0026#39;GET\u0026#39;: return render(request, \u0026#39;file_upload.html\u0026#39;) elif request.method == \u0026#39;POST\u0026#39;: upload_file = request.FILES[\u0026#39;myfile\u0026#39;] print(\u0026#34;上传的文件名是：\u0026#34;, upload_file.name) file_path = os.path.join(settings.MEDIA_ROOT, upload_file.name) with open(file_path, \u0026#39;wb\u0026#39;) as f: data = upload_file.file.read() f.write(data) return HttpResponse(\u0026#34;接收文件：\u0026#34; + upload_file.name + \u0026#34;成功\u0026#34;) 文件写入方案2：ORM\n# 字段名：FileField(upload=\u0026#39;子目录名\u0026#39;) @csrf_exempt def file_upload(request): if request.method == \u0026#39;GET\u0026#39;: return render(request, \u0026#39;file_upload.html\u0026#39;) elif request.method == \u0026#39;POST\u0026#39;: upload_title = request.POST[\u0026#39;title\u0026#39;] upload_file = request.FILES[\u0026#39;myfile\u0026#39;] Content.objects.create(desc=upload_title, myfile=upload_file) return HttpResponse(\u0026#34;接收文件：\u0026#34; + upload_file.name + \u0026#34;成功\u0026#34;) 文件上传代码测试：\n配置上传文件的访问路径和存储路径。\n# settings.py # 存储的路由 MEDIA_URL = \u0026#39;/media/\u0026#39; # 存储的位置 MEDIA_ROOT = os.path.join(BASE_DIR, \u0026#39;media\u0026#39;) 编写html静态文件。\n# apps/templates \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;文件上传\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/file/upload/\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt;{% csrf_token %} \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;myfile\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 编写model模型文件。\nfrom django.db import models # Create your models here. class Content(models.Model): \u0026#34;\u0026#34;\u0026#34; 文件存储对象 \u0026#34;\u0026#34;\u0026#34; title = models.CharField(\u0026#39;文件名\u0026#39;, max_length=11) #子目录的名称即为：upload_to所指定的字段 picture = models.FileField(\u0026#39;子目录名称\u0026#39;, upload_to=\u0026#39;picture\u0026#39;) 编写view视图文件。\nport render from django.http import HttpResponse from .models import * # Create your views here. def file_upload(request): if request.method == \u0026#39;GET\u0026#39;: return render(request, \u0026#39;file_upload.html\u0026#39;) elif request.method == \u0026#39;POST\u0026#39;: title = request.POST[\u0026#39;title\u0026#39;] myfile = request.FILES[\u0026#39;myfile\u0026#39;] Content.objects.create(title=title, picture=myfile) return HttpResponse(\u0026#34;文件上传成功\u0026#34;) else: return HttpResponse(\u0026#34;请求方法错误\u0026#34;) 编写url路由文件。\nfrom django.urls import path, re_path from . import views urlpatterns = [ path(\u0026#34;upload/\u0026#34;, views.file_upload, name=\u0026#34;file_upload\u0026#34;) ] 请求测试。\n文件上传成功。\n使用URL进行访问。\n16.项目部署 16.1 基本概念 项目部署是指在软件开发完毕后，将开发机器上运行的软件实际安装到服务器上进行长期运行。\n在安装机器上安装和配置同版本的环境[python，数据库等]\ndjango项目迁移\nscp /home/euansu/Code/Python/website euansu@xx.xx.xx.xx:/home/euansu/xxx 用uWSGI替代python3 manage.py runserver方法启动服务器。\n配置nginx反向代理服务器。\n用nginx配置静态文件路径，解决静态路径问题。\n16.2 WSGI定义 WSGI（Web Server Gateway Interface）Web服务器网关接口，是Python应用程序或框架和web服务器之间的一种接口，被广泛使用。\n使用Python manage.py runserver通常只在开发和测试环境中使用，当开发结束后，完善的项目代码需要在一个搞笑稳定的环境中运行，这是可以使用WSGI。\n开发环境中，runserver将http协议的内容规范成WSGI规范给Django处理，将WSGI的规范转换成http规范进行返回。\n16.3 uWSGI 16.3.1 uWSGI定义 uWSGI是WSGI的一种，它实现了http协议WSGI协议以及uwsgi协议。uWSGI功能完善，支持协议众多，在Python web热度极高。\nuWSGI主要以学习配置为主。\n16.3.2 uWSGI安装 pip install uwsgi==2.0.18 -i https://pypi.tuna.tsinghua.edu.cn/simple/ # 检查是否安装成功，如果成功安装则会输出uWSGI==2.0.18 pip freeze | grep -i \u0026#39;uwsgi\u0026#39; 16.3.3 uWSGI配置 添加配置文件 项目同名文件夹/uwsgi.ini，如：website/website/uwsgi.ini\n文件以[uwsgi]开头，有如下配置项：\n套接字方式的 IP地址:端口号 【此模式需要有nginx】\nsocket=127.0.0.1:8000 http通信方式的 IP地址:端口号\nhttp=127.0.0.1:8000 项目当前工作目录\nchdir=/home/euansu/website 项目中wsgi.py文件的目录，相对于当前工作目录\nwsgi-file=website/wsgi.py 进程个数\nprocess=4 每个进程的线程个数\nthreads=2 服务的pid记录文件\npidfile=uwsgi.pid 服务的日志文件，配置该选项后，说明项目后台启动，且日志输出到该文件中\ndaemonize=uwsgi.log 开启主进程管理模式\nmaster=true 特殊说明，Django的setting.py需要做如下配置：\n修改settings.py，将DEBUG=True改为DEBUG=False 修改settings.py，将ALLOWED_HOSTS=[] 改为 ALLOWED_HOSTS=[\u0026lsquo;网站域名/服务器监听的ip地址\u0026rsquo;] 实际项目的配置文件如下：\n# 项目名/uwsgi.ini [uwsgi] # http通信方式的 IP地址:端口号 http=127.0.0.1:8000 # 项目当前工作目录 chdir=/home/euansu/Code/Python/website # 项目中wsgi.py文件的位置 wsgi-file=website/wsgi.py # 进程个数 process=4 # 线程个数 threads=2 # 服务的pid记录文件 pidfile=uwsgi.pid # 服务的日志文件，是不是由后台启动以及日志输出到哪里 daemonize=uwsgi.log # 开启主进程管理模式 master=true 16.3.4 uWSGI的运行管理 启动uwsgi\n# cd到uWSGI配置文件所在目录 uwsgi --ini uwsgi.ini 启动以及检测进程是否成功。\n网页访问。\n停止uwsgi\n# cd到uWSGI配置文件所在目录 uwsgi --stop uwsgi.pid 16.4 项目部署测试 将项目上传至远程linux主机。\n启动项目，这里需要提前在远程linux主机安装python以及所需要的依赖项。\n页面能够正常访问到django项目的内容。\n注：这里启动的时候要注意，命令应该是 python manage.py runserver 0.0.0.0:8080，否则有可能出现无法访问的现象。\n远程主机安装uWSGI。\n这里安装uWSGI失败，报错如下，暂时无法解决，这里改用gunicorn进行项目的部署。\n安装Gunicorn。\npip install uvicorn pip install gunicorn 运行项目\n# 后台启动 gunicorn --bind 0.0.0.0:8080 website.wsgi:application --daemon 页面能够正常访问项目。\n","date":"2024-01-24T11:57:38+08:00","image":"https://euansu123.github.io/img/%E8%BE%BE%E5%86%85%E6%95%99%E8%82%B2Django%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B.jpg","permalink":"https://euansu123.github.io/post/django_tutorial/","title":"达内教育Django全套教程"},{"content":"YARN 1.YARN常用命令 1.1 作业 命令 说明 yarn application -list 列出所有的application yarn application -list -appStates [ALL、NEW、NEW_SAVING、SUBMITTED、ACCEPTED、RUNNING、FINISHED、FAILED、KILLED] 根据application状态过滤 yarn application -kill [applicationId] Kill掉application 查看所有任务\nyarn application -list 查看指定任务状态的作业\n# state 可选的有：ALL、NEW、NEW_SAVING、SUBMITTED、ACCEPTED、RUNNING、FINISHED、FAILED、KILLED yarn application -list -appStates \u0026lt;state\u0026gt; # 示例 yarn application -list -appStates RUNNING,ACCEPTED 查看正在运行的任务信息\nyarn applicationattempt -list \u0026lt;application_id\u0026gt; 结束作业\nyarn application -kill \u0026lt;application_id\u0026gt; 1.2 日志 查询指定作业的日志\n# 如果提示内存限制，可以在如下命令后，添加 --size -1 yarn logs -applicationId \u0026lt;application_id\u0026gt; 查询指定 Container 的日志\nyarn logs -applicationId \u0026lt;application_id\u0026gt; -containerId \u0026lt;container_id\u0026gt; 1.3 Application Attempt 命令 说明 yarn applicationattempt -list [ApplicationId] 列出所有Application尝试的列表 yarn applicationattempt -status [ApplicationAttemptId] 打印Application Attempt的状态 列出Application的所有尝试\nyarn applicationattempt -list [ApplicationId] 打印Application Attempt的状态\nyarn applicationattempt -status [ApplicationAttemptId] 1.4 容器 命令 说明 yarn container -list [ApplicationAttemptId] 列出所有的Container yarn container -status [ContainerId] 打印Container状态 列出所有的Container\nyarn container -list [ApplicationAttemptId] 打印Container状态\nyarn container -status [ContainerId] 1.5 其他 命令 说明 yarn node -list -all 查看节点状态 yarn rmadmin -refreshQueues 加载队列配置 yarn queue -status [QueueName] 打印队列信息 查看节点状态\nyarn node -list -all 加载队列配置\n# 需要在RM节点执行 yarn rmadmin -refreshQueues 查看队列状态\nyarn queue -status [QueueName] 2.YARN Rest Api YARN Rest Api文档地址：https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html\n2.1 集群 获取 RM 节点状态\n# URL http://rm-http-address:port/ws/v1/cluster/info # Method GET # 示例 curl -X GET -u e3base:\u0026#39;Sit@Paas\u0026amp;123\u0026#39; -i \u0026#34;http://172.21.9.101:13006/ws/v1/cluster/info\u0026#34; # 注：如果集群集成了kerbeors，需要增加--negotiate参数 获取集群Metrics\n# URL http://rm-http-address:port/ws/v1/cluster/metrics # Method GET # 示例 curl -X GET -u e3base:\u0026#39;Sit@Paas\u0026amp;123\u0026#39; -i \u0026#34;http://172.21.9.101:13006/ws/v1/cluster/metrics\u0026#34; # 注：如果集群集成了kerbeors，需要增加--negotiate参数 2.2 队列 获取集群队列\n# URL http://rm-http-address:port/ws/v1/cluster/scheduler # Method GET # 示例 curl -X GET -u e3base:\u0026#39;Sit@Paas\u0026amp;123\u0026#39; -i \u0026#34;http://172.21.9.101:13006/ws/v1/cluster/scheduler\u0026#34; # 注：如果集群集成了kerbeors，需要增加--negotiate参数 2.3 作业 获取集群作业\n# URL http://rm-http-address:port/ws/v1/cluster/apps # Method GET # 示例 curl -X GET -u e3base:\u0026#39;Sit@Paas\u0026amp;123\u0026#39; -i \u0026#34;http://172.21.9.101:13006/ws/v1/cluster/apps\u0026#34; # 注：如果集群集成了kerbeors，需要增加--negotiate参数 3.其他 3.1 相关资源 YARN官方文档：https://hadoop.apache.org/docs/stable/ 大数据之Hadoop集群中YARN常用命令：https://www.cnblogs.com/sw-code/p/16387038.html ","date":"2024-01-22T11:57:38+08:00","image":"https://euansu123.github.io/img/hadoop.png","permalink":"https://euansu123.github.io/post/yarn_rest_api/","title":"YARN常用命令及Rest API"},{"content":"Kerberos Kerberos 是一个用于服务请求时在服务端和客户端进行身份认证的服务，Kerberos支持在所有操作系统上进行构建，包括有 Windows、macOS、FrssBSD 和 Linux。\n官方网址：https://www.kerberos.org/\n1.Kerberos 环境 Kerberos 环境下访问远程主机的服务，需要在主机上先进行认证，然后才可以携带 kerbeors 主机和 keytab 文件访问。\n1.1 Kerbero 主机认证 # keytab_file:keytab文件路径 # kerberos_principal:kerbeors的principal kinit -kt \u0026lt;keytab_file\u0026gt; \u0026lt;kerberos_principal\u0026gt; 1.2 Kerberos环境下的curl # method:请求方法,例如GET、POST、PUT... # negotiate:指定kerberos环境，会携带当前主机认证的kerberos principal进行访问 # username:用户名 # password:密码 # url:要请求的服务地址 curl -X \u0026lt;method\u0026gt; --negotiate -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -i url 2.Python 2.1 第三方包安装 pip install requests pip install requests_kerberos pip install krbcontext 2.2 工具类 这里以 Python 调用 Hadoop 的 Rest 接口为例，测试 Python 在 Kerberos 环境下的服务调用。\nHadoop Rest 接口文档地址：https://hadoop.apache.org/docs/r1.0.4/webhdfs.html\n# -*- coding=utf-8 -*- import json import logging import requests import posixpath from requests.auth import HTTPBasicAuth from requests_kerberos import HTTPKerberosAuth from krbcontext import krbContext _NAMENODE_STATUS_URL = \u0026#39;jmx\u0026#39; _HDFS_REST_URL = \u0026#39;webhdfs/v1\u0026#39; _ACCEPT_CONTENT_TYPE = \u0026#39;application/json\u0026#39; LOG = logging.getLogger(__name__) class HdfsRestApi(object): \u0026#34;\u0026#34;\u0026#34; HDFS Rest 接口工具类 \u0026#34;\u0026#34;\u0026#34; def __init__(self, url, username, password, security_enabled=False, principal=None, keytab_file=None): self._url = posixpath.join(url) self._username = username self._password = password self._security_enabled = security_enabled self._auth = HTTPBasicAuth(self._username, self._password) if self._security_enabled: with krbContext(using_keytab=True, principal=principal, keytab_file=keytab_file): self._auth = HTTPKerberosAuth() def __str__(self): return \u0026#34;HDFS Rest Url Address Is {HDFS_REST_URL}\u0026#34;.format(HDFS_REST_URL=self._url) def _get_params(self, params=None): params = params if params is not None else {} return params def get_namenode_status(self): \u0026#34;\u0026#34;\u0026#34; 获取NameNode的状态信息 @return: \u0026#34;\u0026#34;\u0026#34; result = {\u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39;} url = posixpath.join(self._url, _NAMENODE_STATUS_URL) params = self._get_params({\u0026#34;qry\u0026#34;: \u0026#34;Hadoop:service=NameNode,name=NameNodeStatus\u0026#34;}) try: response = requests.get(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) if response.status_code == 200: result[\u0026#39;data\u0026#39;] = json.loads(response.text) else: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = response.text except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) return result def get_path_quota(self, path): \u0026#34;\u0026#34;\u0026#34; 获取路径的配额信息（空间配额） @return: \u0026#34;\u0026#34;\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } path = path[1:] if path.startswith(\u0026#39;/\u0026#39;) else path url = posixpath.join(self._url, _HDFS_REST_URL, path) params = self._get_params({\u0026#34;op\u0026#34;: \u0026#34;GETQUOTAUSAGE\u0026#34;}) try: response = requests.get(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) if response.status_code == 200: result[\u0026#39;data\u0026#39;] = json.loads(response.text) else: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = response.text except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) return result def set_path_quota(self, path, quota): \u0026#34;\u0026#34;\u0026#34; 设置路径的配额信息（空间配额） @return: \u0026#34;\u0026#34;\u0026#34; # curl -i -X PUT \u0026#34;http://\u0026lt;HOST\u0026gt;:\u0026lt;PORT\u0026gt;/webhdfs/v1/\u0026lt;PATH\u0026gt;?op=SETQUOTA # \u0026amp;namespacequota=\u0026lt;QUOTA\u0026gt;[\u0026amp;storagespacequota=\u0026lt;QUOTA\u0026gt;]\u0026#34; # namespacequota 指定目录中的最大文件和目录数 # storagespacequota 目录的最大空间使用量 result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } path = path[1:] if path.startswith(\u0026#39;/\u0026#39;) else path url = posixpath.join(self._url, _HDFS_REST_URL, path) params = self._get_params({\u0026#34;op\u0026#34;: \u0026#34;SETQUOTA\u0026#34;, \u0026#34;storagespacequota\u0026#34;: quota}) try: response = requests.put(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) if response.status_code != 200: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = \u0026#34;设置配额出现异常，请联系管理员处理\u0026#34; except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) return result # Directory def get_directory_list(self, path): \u0026#34;\u0026#34;\u0026#34; 获取路径下的文件及目录列表 @param path: @return: \u0026#34;\u0026#34;\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } try: path = path[1:] if path.startswith(\u0026#39;/\u0026#39;) else path url = posixpath.join(self._url, _HDFS_REST_URL, path) print url params = self._get_params({\u0026#34;op\u0026#34;: \u0026#34;LISTSTATUS\u0026#34;}) try: response = requests.get(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) if response.status_code == 200: response_data = json.loads(response.text) if \u0026#39;FileStatuses\u0026#39; in response_data and \u0026#39;FileStatus\u0026#39; in response_data[\u0026#39;FileStatuses\u0026#39;]: result[\u0026#39;data\u0026#39;] = response_data[\u0026#39;FileStatuses\u0026#39;][\u0026#39;FileStatus\u0026#39;] else: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#39;HDFS Rest 接口数据发生变化，请联系开发人员进行处理\u0026#39; elif response.status_code == 404: result[\u0026#39;code\u0026#39;] = 404 result[\u0026#39;message\u0026#39;] = \u0026#39;要查询的路径不存在\u0026#39; else: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = response.text except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) except Exception as e: LOG.exception(e) result[\u0026#39;message\u0026#39;] = \u0026#39;代码运行时发生错误，错误原因：{error_message}\u0026#39;.format(error_message=e) return result def create_directory(self, path): \u0026#34;\u0026#34;\u0026#34; 创建HDFS目录并指定用户 @param path: @return: \u0026#34;\u0026#34;\u0026#34; # curl -i -X PUT \u0026#34;http://\u0026lt;HOST\u0026gt;:\u0026lt;PORT\u0026gt;/\u0026lt;PATH\u0026gt;?op=MKDIRS[\u0026amp;permission=\u0026lt;OCTAL\u0026gt;]\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } try: path = path[1:] if path.startswith(\u0026#39;/\u0026#39;) else path url = posixpath.join(self._url, _HDFS_REST_URL, path) params = self._get_params({\u0026#34;op\u0026#34;: \u0026#34;MKDIRS\u0026#34;}) try: response = requests.put(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) if response.status_code != 200: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = response.text except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) except Exception as e: LOG.exception(e) result[\u0026#39;message\u0026#39;] = \u0026#39;代码运行时发生错误，错误原因：{error_message}\u0026#39;.format(error_message=e) return result def set_path_owner(self, path, user): \u0026#34;\u0026#34;\u0026#34; 设置HDFS路径的owner @param path: @param user: @return: \u0026#34;\u0026#34;\u0026#34; # curl -i -X PUT \u0026#34;http://\u0026lt;HOST\u0026gt;:\u0026lt;PORT\u0026gt;/webhdfs/v1/\u0026lt;PATH\u0026gt;?op=SETOWNER # [\u0026amp;owner=\u0026lt;USER\u0026gt;][\u0026amp;group=\u0026lt;GROUP\u0026gt;]\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } try: path = path[1:] if path.startswith(\u0026#39;/\u0026#39;) else path url = posixpath.join(self._url, _HDFS_REST_URL, path) params = self._get_params({\u0026#34;op\u0026#34;: \u0026#34;SETOWNER\u0026#34;, \u0026#34;owner\u0026#34;: user, \u0026#34;group\u0026#34;: user}) try: response = requests.put(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) if response.status_code != 200: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = response.text except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) except Exception as e: LOG.exception(e) result[\u0026#39;message\u0026#39;] = \u0026#39;代码运行时发生错误，错误原因：{error_message}\u0026#39;.format(error_message=e) return result def delete_directory(self, path): \u0026#34;\u0026#34;\u0026#34; 删除HDFS目录 @param path: @return: \u0026#34;\u0026#34;\u0026#34; # curl -i -X DELETE \u0026#34;http://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt;/webhdfs/v1/\u0026lt;path\u0026gt;?op=DELETE # [\u0026amp;recursive=\u0026lt;true|false\u0026gt;]\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } try: path = path[1:] if path.startswith(\u0026#39;/\u0026#39;) else path url = posixpath.join(self._url, _HDFS_REST_URL, path) params = self._get_params({\u0026#34;op\u0026#34;: \u0026#34;DELETE\u0026#34;}) try: response = requests.delete(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) if response.status_code != 200: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = response.text except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) except Exception as e: LOG.exception(e) result[\u0026#39;message\u0026#39;] = \u0026#39;代码运行时发生错误，错误原因：{error_message}\u0026#39;.format(error_message=e) return result def get_path_status(self, path): \u0026#34;\u0026#34;\u0026#34; 获取HDFS路径的状态 @param path: @return: \u0026#34;\u0026#34;\u0026#34; # curl -i \u0026#34;http://\u0026lt;HOST\u0026gt;:\u0026lt;PORT\u0026gt;/webhdfs/v1/\u0026lt;PATH\u0026gt;?op=GETFILESTATUS\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } try: path = path[1:] if path.startswith(\u0026#39;/\u0026#39;) else path url = posixpath.join(self._url, _HDFS_REST_URL, path) params = self._get_params({\u0026#34;op\u0026#34;: \u0026#34;GETFILESTATUS\u0026#34;}) try: response = requests.get(url, params=params, headers={\u0026#39;Accept\u0026#39;: _ACCEPT_CONTENT_TYPE}, auth=self._auth) print response if response.status_code == 200: response_data = json.loads(response.text) if \u0026#39;FileStatus\u0026#39; in response_data: result[\u0026#39;data\u0026#39;] = response_data[\u0026#39;FileStatus\u0026#39;] else: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#39;HDFS Rest 接口数据发生变化，请联系开发人员进行处理\u0026#39; elif response.status_code == 404: result[\u0026#39;code\u0026#39;] = 404 result[\u0026#39;message\u0026#39;] = \u0026#39;要查询的路径不存在\u0026#39; else: result[\u0026#39;code\u0026#39;] = response.status_code result[\u0026#39;message\u0026#39;] = response.text except requests.exceptions.RequestException as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#34;请求出现异常：{error_message}\u0026#34;.format(error_message=e) except Exception as e: LOG.exception(e) result[\u0026#39;message\u0026#39;] = \u0026#39;代码运行时发生错误，错误原因：{error_message}\u0026#39;.format(error_message=e) return result def get_active_namenode(url_list, username, password, security_enabled=False, principal=None, keytab_file=None): \u0026#34;\u0026#34;\u0026#34; 获取active状态的NameNode节点 @param url_list: @param username: @param password: @param security_enabled: @return: \u0026#34;\u0026#34;\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } try: for item in url_list: hdfs_rest_api = HdfsRestApi(item, username, password, security_enabled=security_enabled, principal=principal, keytab_file=keytab_file) get_status_result = hdfs_rest_api.get_namenode_status() if get_status_result[\u0026#39;code\u0026#39;] == 200: if \u0026#39;beans\u0026#39; in get_status_result[\u0026#39;data\u0026#39;] and len(get_status_result[\u0026#39;data\u0026#39;][\u0026#39;beans\u0026#39;]) \u0026gt; 0: namenode_state = get_status_result[\u0026#39;data\u0026#39;][\u0026#39;beans\u0026#39;][0][\u0026#39;State\u0026#39;] if namenode_state.lower() == \u0026#39;active\u0026#39;: result[\u0026#39;data\u0026#39;] = hdfs_rest_api return result else: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#39;HDFS Rest 接口数据发生变化，请联系开发人员进行处理\u0026#39; return result else: result[\u0026#39;code\u0026#39;] = get_status_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = get_status_result[\u0026#39;message\u0026#39;] except Exception as e: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#39;代码运行发生了错误：{error_message}\u0026#39;.format(error_message=e) return result def create_hdfs_directory(url_list, username, password, tenant, path, quota, security_enabled=False, principal=None, keytab_file=None): \u0026#34;\u0026#34;\u0026#34; 创建HDFS目录 @param url_list: @param username: @param password: @param tenant: @param path: @param quota: @param security_enabled: @param principal: @param keytab_file: @return: \u0026#34;\u0026#34;\u0026#34; result = { \u0026#39;code\u0026#39;:200, \u0026#39;message\u0026#39;:\u0026#39;success\u0026#39; } get_active_result = get_active_namenode(url_list, username, password, security_enabled=security_enabled, principal=principal, keytab_file=keytab_file) if get_active_result[\u0026#39;code\u0026#39;] == 200: hdfs_rest_api = get_active_result[\u0026#39;data\u0026#39;] # 确定路径是否存在 get_path_status_result = hdfs_rest_api.get_path_status(path) if get_path_status_result[\u0026#39;code\u0026#39;] == 200: # 删除 result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;message\u0026#39;] = \u0026#39;HDFS路径{hdfs_path}已存在\u0026#39;.format(hdfs_path=path) elif get_path_status_result[\u0026#39;code\u0026#39;] == 404: # 创建目录 create_hdfs_directory_result = hdfs_rest_api.create_directory(path) if create_hdfs_directory_result[\u0026#39;code\u0026#39;] == 200: set_path_quota_result = hdfs_rest_api.set_path_quota(path, quota) if set_path_quota_result[\u0026#39;code\u0026#39;] == 200: hdfs_rest_api.set_path_owner(path, tenant) else: # 删除路径 result[\u0026#39;code\u0026#39;] = 505 result[\u0026#39;message\u0026#39;] = set_path_quota_result[\u0026#39;message\u0026#39;] else: result[\u0026#39;code\u0026#39;] = create_hdfs_directory_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = create_hdfs_directory_result[\u0026#39;message\u0026#39;] else: result[\u0026#39;code\u0026#39;] = get_path_status_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = get_active_result[\u0026#39;message\u0026#39;] else: result[\u0026#39;code\u0026#39;] = get_active_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = get_active_result[\u0026#39;message\u0026#39;] return result def setting_path_quota(url_list, username, password, path, quota, security_enabled=False, principal=None, keytab_file=None): \u0026#34;\u0026#34;\u0026#34; 设置HDFS路径配额 @param url_list: @param username: @param password: @param security_enabled: @param principal: @param keytab_file: @return: \u0026#34;\u0026#34;\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } get_active_result = get_active_namenode(url_list, username, password, security_enabled=security_enabled, principal=principal,keytab_file=keytab_file) if get_active_result[\u0026#39;code\u0026#39;] == 200: hdfs_rest_api = get_active_result[\u0026#39;data\u0026#39;] # 确定路径是否存在 get_path_status_result = hdfs_rest_api.get_path_status(path) if get_path_status_result[\u0026#39;code\u0026#39;] == 200: # 设置配额 set_path_quota_result = hdfs_rest_api.set_path_quota(path, quota) if set_path_quota_result[\u0026#39;code\u0026#39;] != 200: result[\u0026#39;code\u0026#39;] = set_path_quota_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = set_path_quota_result[\u0026#39;message\u0026#39;] elif get_path_status_result[\u0026#39;code\u0026#39;] == 404: result[\u0026#39;code\u0026#39;] = get_path_status_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = \u0026#39;修改配额操作失败：HDFS路径{hdfs_path}不存在\u0026#39;.format(hdfs_path=path) else: result[\u0026#39;code\u0026#39;] = get_path_status_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = get_active_result[\u0026#39;message\u0026#39;] else: result[\u0026#39;code\u0026#39;] = get_active_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = get_active_result[\u0026#39;message\u0026#39;] return result def delete_hdfs_path(url_list, username, password, path, security_enabled=False, principal=None, keytab_file=None): \u0026#34;\u0026#34;\u0026#34; 删除HDFS的目录或文件 @param url_list: @param username: @param password: @param path: @param security_enabled: @param principal: @param keytab_file: @return: \u0026#34;\u0026#34;\u0026#34; result = { \u0026#39;code\u0026#39;: 200, \u0026#39;message\u0026#39;: \u0026#39;success\u0026#39; } get_active_result = get_active_namenode(url_list, username, password, security_enabled=security_enabled, principal=principal, keytab_file=keytab_file) if get_active_result[\u0026#39;code\u0026#39;] == 200: hdfs_rest_api = get_active_result[\u0026#39;data\u0026#39;] # 确定路径是否存在 get_path_status_result = hdfs_rest_api.get_path_status(path) if get_path_status_result[\u0026#39;code\u0026#39;] == 200: # 删除 delete_directory_reuslt = hdfs_rest_api.delete_directory(path) if delete_directory_reuslt[\u0026#39;code\u0026#39;] != 200: result[\u0026#39;code\u0026#39;] = delete_directory_reuslt[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = delete_directory_reuslt[\u0026#39;message\u0026#39;] elif get_path_status_result[\u0026#39;code\u0026#39;] == 404: result[\u0026#39;code\u0026#39;] = get_path_status_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = \u0026#39;删除操作失败：HDFS路径{hdfs_path}不存在\u0026#39;.format(hdfs_path=path) else: result[\u0026#39;code\u0026#39;] = get_path_status_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = get_active_result[\u0026#39;message\u0026#39;] else: result[\u0026#39;code\u0026#39;] = get_active_result[\u0026#39;code\u0026#39;] result[\u0026#39;message\u0026#39;] = get_active_result[\u0026#39;message\u0026#39;] return result 2.3 代码测试 main 方法中调用工具类，获取目录文件以及目录的状态。\n返回内容如下，Kerberos 环境下 Python 的接口调用操作成功。\n","date":"2023-08-03T11:10:00+08:00","image":"https://euansu123.github.io/img/kerberos.png","permalink":"https://euansu123.github.io/post/kerberos_python_request/","title":"Kerberos环境下Python的接口调用"},{"content":"FastApi FastApi 是一个现代、快速（高性能）的 web 框架，用于基于标准Python构建的API。\n官方网址：https://fastapi.tiangolo.com/\n1.安装 1.1 环境信息 # Python版本 3.8.0 1.2 安装 FastApi pip install fastapi # uvicorn 作为服务启动fastapi框架 pip install uvicorn 2.使用 # 导入FastAPI第三方包 from fastapi import FastAPI # 创建FastAPI对象 app = FastAPI() # 路由地址 @app.get(\u0026#34;/\u0026#34;) # 后端方法 def read_root(): return {\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;} 3.部署 3.1 Gunicorn Gunicorn 是一个 unix 上被广泛使用的高性能 Python WSGI Unix Http Server，和大多数的 Web 框架兼容，并具有实现简单，轻量级，高性能的特点。\n3.1.1 安装 Gunicorn pip install uvicorn pip install gunicorn 3.1.2 运行项目 3.1.2.1 以配置文件的方式运行项目 配置文件\n# -*- coding=utf-8 -*- import os # 设置守护进程 daemon = True # 监听内网端口 bind = \u0026#39;0.0.0.0:8000\u0026#39; # 进程文件目录 pidfile = \u0026#39;./gunicorn.pid\u0026#39; chdir = \u0026#39;./\u0026#39; # 工作模式 worker_class=\u0026#39;uvicorn.workers.UvicornWorker\u0026#39; # 并行工作进程数 workers = 3 # 线程数 threads = 2 # 设置最大并发量 worker_connections = 1000 loglevel = \u0026#39;debug\u0026#39; access_log_format = \u0026#39;%(t)s %(p)s %(h)s \u0026#34;%(r)s %(s)s %(L)s %(b)s %(f)s\u0026#34; \u0026#34;%(a)s\u0026#34;\u0026#39; # 设置日志保存路径 log_dir = \u0026#39;./log\u0026#39; if not os.path.exists(log_dir): os.mkdir(log_dir) accesslog = \u0026#39;./log/gunicorn_access.log\u0026#39; errorlog = \u0026#39;./log/gunicorn_error.log\u0026#39; 运行项目\ngunicorn main:app -c gunicorn.py 3.1.2.2 直接运行项目 gunicorn main:app -b 0.0.0.0:8000 -w 4 -k uvicorn.workers.UvicornWorker --daemon ","date":"2023-08-02T19:10:00+08:00","image":"https://euansu123.github.io/img/fastapi.png","permalink":"https://euansu123.github.io/post/fastapi_tutor/","title":"FastApi搭建部署"},{"content":"Nginx是一个高性能的web服务器和反向代理服务器，以其低内存使用率和强大的并发能力而闻名。它最初由Igor Sysoev编写，并以类似BSD的2条款许可证发行。Nginx可以处理各种协议，如HTTP、TCP、UDP、IMAP、POP3和SMTP。它被Yandex、Mail.Ru、VK、Rambler、Dropbox、Netflix、Wordpress.com、FastMail.FM等许多负载沉重的网站广泛使用和信任。\n正向代理和反向代理 正向代理 概念 特点 正向代理需要主动设置代理服务器 ip 或域名进行访问，由设置的ip 或域名去访问内容并返回。 正向代理是代理客户端，为客户端收发请求，使得真实的客户端对服务器不可见。 概念 特点 正向代理需要配置代理服务器，而反向代理不需要做任何设置。 反向代理是代理服务器，为服务器收发请求，使得真实服务器对客户端不可见。 正向代理和反向代理的比较 相同点 正向代理和反向代理所处的位置都是客户端与真实提供服务的服务器之间。 正向代理和反向代理都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端。 不同点 正向代理是客户端的代理，服务器并不知道真正的客户端是谁，反向代理是服务器的代理，客户端并不知道真正的服务器是谁； 正向代理一般是客户端架设，反向代理一般是服务器架设； 正向代理主要是为了解决访问限制问题，反向代理主要是为了提供负载均衡、安全防护等。 Nginx 负载均衡 概念 负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。\n负载均衡构建在原有网络结构之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性。\n简言之，负载均衡实际上就是将大量请求进行分布式处理的策略。\n负载均衡实现 upstream testServer { server localhost:8081; server localhost:8082; server localhost:8083; } server { listen 8000; server_name localhost; location / { root html; index index.html index.htm; proxy_pass http://testServer; } } localhost:8081、localhost:8082、localhost:8083分别为如下页面：\n访问 localhost:8000 会出现如上页面。\n负载均衡常用算法 轮询 轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。假设配置文件中共有 M 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。\nNginx 安装 依赖库安装 # gcc g++ sudo yum install build-essential sudo yum install libtool # pcre sudo yum install libpcre3 libpcre3-dev # zlib sudo yum install zlib1g-dev # ssl sudo yum install openssl sudo yum install libssl-dev Nginx 源码编译安装 # 下载 $ wget https://nginx.org/download/nginx-1.17.8.tar.gz # 解压 $ tar -zxvf nginx-1.17.8.tar.gz # 进入目录 $ cd nginx-1.17.8 # 配置，这里可能会报错，缺少啥就去安装啥 $ ./configure --prefix=/usr/local/nginx \\ --with-http_gzip_static_module \\ --with-http_v2_module \\ --with-pcre \\ --with-http_ssl_module # 生成makefile文件 make # 安装 make install Nginx 代理二级域名 新增一个 server 块，监听的端口依然是 80 端口，如果配置的端口为非 80 端口，则需要携带端口访问 http 服务。\nserver { listen 80; server_name cloud.euansu.cn; index index.php; #location / { # proxy_set_header Host $http_host; # proxy_pass http://cloud.euansu.cn:8000; #} location / { root /kodbox; } location ~ \\.php$ { root /kodbox; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /kodbox$fastcgi_script_name; include fastcgi_params; } } Nginx 配置https 新增一个 server 块，监听的端口依然是 443 端口，如果配置的端口为非 443 端口，则需要携带端口访问 https 服务。\nserver { listen 443 ssl; server_name cloud.euansu.cn; index index.php; ssl_certificate /www/nginx/cert/cloud.euansu.cn.pem; ssl_certificate_key /www/nginx/cert/cloud.euansu.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { root /kodbox; } location ~ \\.php$ { root /kodbox; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /kodbox$fastcgi_script_name; include fastcgi_params; } } ","date":"2023-07-18T09:47:00+08:00","image":"https://euansu123.github.io/img/nginx.png","permalink":"https://euansu123.github.io/post/nginx_base_and_tutorial/","title":"Nginx 基础概念及使用"},{"content":"Prometheus 对大数据组件HDFS的指标进行采集，Grafana进行可视化展示。\n1.Prometheus 下载 Prometheus 安装包。\nwget https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz # 页面下载地址 https://prometheus.io/download/ 上传 Prometheus 到规划的路径并进行解压。\ntar -zxvf prometheus-2.37.8.linux-amd64.tar.gz 启动 Prometheus 服务。\n# 需要在 Prometheus 目录下执行如下操作 ./prometheus --config.file=prometheus.yml # 建议后台启动，命令如下 nohup ./prometheus --config.file=prometheus.yml \u0026gt;\u0026gt; prometheus.log 2\u0026gt;\u0026amp;1 \u0026amp; 启动后，即可在页面访问 Prometheus 服务。\n2.Grafana 下载 Grafana 安装包。\n# 这里下载的是安装包，注意不要下载源码包 wget https://dl.grafana.com/enterprise/release/grafana-enterprise-9.5.2.linux-amd64.tar.gz # 页面下载地址 https://grafana.com/grafana/download/10.0.0?pg=oss-graf\u0026amp;plcmt=hero-btn-1 上传到主机规划的目录并进行解压。\ntar -zxvf grafana-enterprise-9.5.2.linux-amd64.tar.gz 启动 Grafana 服务。\n# 需要在 Grafana 目录下执行如下操作 ./bin/grafana-server web # 建议后台启动，命令如下 nohup ./grafana-server web 2\u0026gt;\u0026amp;1 \u0026gt;\u0026gt; /e3base/apps/grafana/logs/grafana.log \u0026amp; 启动后，即可在页面访问 Grafana 服务。\n3.指标监控 3.1 HDFS 3.1.1 NameNode 环境信息\n# jmx端口 12003 # NameNode节点 host-172-18-243-34 host-172-18-243-35 # 环境 Kerberos jmx 接口测试\ncurl -X GET --negotiate -u e3base:e3base -i http://host-172-18-243-34:12003/jmx curl -X GET --negotiate -u e3base:e3base -i http://host-172-18-243-35:12003/jmx Kerberos代理\nPrometheus 只能够采集非 Kerberos 环境的信息，Kerberos 环境下需要使用如下方法，将 Kerbeors 页面代理成非 Kerberos 页面供 Prometheus 进行数据采集。\n解压附件中的 http_exporter.zip 文件。\nunzip http_exporter.zip 修改 httpjmx.yml 配置文件，设置代理信息。\nhttpTimeout: 10 httpUrl: - \u0026#34;namenode|http://host-172-18-243-34:12003/jmx\u0026#34; blacklistObjectNames: - \u0026#34;Hadoop:service=NameNode,name=NameNodeInfo|LiveNodes|DeadNodes\u0026#34; - \u0026#34;Hadoop:service=NameNode,name=FSNamesystemState|TopUserOpCounts\u0026#34; - \u0026#34;Hadoop:service=DataNode,name=DataNodeInfo|DatanodeNetworkCounts\u0026#34; wightlistObjectNames: - \u0026#34;not use now\u0026#34; valueReplace: - \u0026#34;true:1\u0026#34; - \u0026#34;false:0\u0026#34; - \u0026#34;active:1\u0026#34; - \u0026#34;standby:0\u0026#34; krbSwitch: 1 krbPrincipal: \u0026#34;e3base@SITECH.COM\u0026#34; krbKeyTab: \u0026#34;/etc/security/keytabs/e3base.keytab\u0026#34; krbUseTicketCache: \u0026#34;true\u0026#34; krbRenewTGT: \u0026#34;true\u0026#34; krbRefreshKrb5Config: \u0026#34;true\u0026#34; krbStoreKey: \u0026#34;false\u0026#34; krbIsInitiator: \u0026#34;true\u0026#34; krbDebug: \u0026#34;true\u0026#34; debug: 0 启动 http_exporter 代理服务。\nnohup /e3base/jdk/bin/java -cp collector-0.16.2-SNAPSHOT.jar io.prometheus.jmx.httpjmx.HadoopCollector 172.18.243.36:9102 httpjmx.yml 2\u0026gt;\u0026amp;1 \u0026amp; 配置 Prometheus 的配置文件。\nscrape_configs: # The job name is added as a label `job=\u0026lt;job_name\u0026gt;` to any timeseries scraped from this config. - job_name: \u0026#34;prometheus\u0026#34; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#34;localhost:9090\u0026#34;] - job_name: \u0026#34;namenode\u0026#34; static_configs: - targets: [\u0026#34;172.18.243.36:9102\u0026#34;,\u0026#34;172.18.243.36:9103\u0026#34;] 重启 Prometheus 服务，页面上出现 namenode 的相关数据。\n导入附件中的 namenode.json 到 Grafana，注意修改文件中的 datasource 参数，设置成 Promnetheus 的 target 名称。\n导入后，页面数据正常展示。\n","date":"2023-07-11T19:10:00+08:00","image":"https://euansu123.github.io/img/grafana_prometheus.png","permalink":"https://euansu123.github.io/post/prometheus_and_grafana/","title":"Prometheus + Grafana指标监控"},{"content":"python-crontab 第三方包实现主机上的定时任务。\n1.安装 # 下载python-crontab的安装包 # 解压后，使用python直接进行安装 build/env/bin/python2.7 setup.py install https://files.pythonhosted.org/packages/6b/ff/42c11cf843eedaff89c6ac5e65ab9935cb4af7bd13621708036ea8352d38/python-crontab-2.5.0.tar.gz\n2.使用 # -*- coding=utf-8 -*- import logging from crontab import CronTab LOG = logging.getLogger(__name__) class CrontabTask(object): \u0026#34;\u0026#34;\u0026#34; 定时任务方法类 \u0026#34;\u0026#34;\u0026#34; def __init__(self): self.cron = CronTab(user=True) def addTask(self, cmd, task_name, time_dic): \u0026#34;\u0026#34;\u0026#34; 新增定时任务 @param cmd: @param task_name: @param time_dic: @return: \u0026#34;\u0026#34;\u0026#34; result = None try: task = self.cron.new(command=cmd, comment=task_name) if \u0026#39;minute\u0026#39; in time_dic: task.minute.every(time_dic[\u0026#39;minute\u0026#39;]) if \u0026#39;hour\u0026#39; in time_dic: task.hour.every(time_dic[\u0026#39;hour\u0026#39;]) self.cron.write() except Exception as e: LOG.exception(e) result = e return result def editTask(self, cmd, task_name, time_dic): \u0026#34;\u0026#34;\u0026#34; 编辑定时任务 @param cmd: @param task_name: @param time_dic: @return: \u0026#34;\u0026#34;\u0026#34; result = None try: tasks = self.cron.find_comment(task_name) for task in tasks: task.set_command(cmd) if \u0026#39;minute\u0026#39; in time_dic: task.minute.every(time_dic[\u0026#39;minute\u0026#39;]) if \u0026#39;hour\u0026#39; in time_dic: task.hour.every(time_dic[\u0026#39;hour\u0026#39;]) self.cron.write() except Exception as e: LOG.exception(e) result = e return result def deleteTask(self, task_name): \u0026#34;\u0026#34;\u0026#34; 删除定时任务 @param task_name: @return: \u0026#34;\u0026#34;\u0026#34; result = None try: tasks = self.cron.find_comment(task_name) for job in tasks: self.cron.remove(job) self.cron.write() except Exception as e: LOG.exception(e) result = e return result def getTasks(self): \u0026#34;\u0026#34;\u0026#34; 获取定时任务的信息 @return: \u0026#34;\u0026#34;\u0026#34; result = [] try: tasks = str(self.cron).split(\u0026#39;\\n\u0026#39;) for task in tasks: if task != \u0026#39;\u0026#39;: result.append(task.replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;)) except Exception as e: LOG.exception(e) result = e return result 3.测试 3.1 获取定时任务 执行Python代码查看当前用户的定时任务。\n直接通过crontab命令查看当前用户的定时任务，两者内容一致。\n3.2 新增定时任务 执行Python代码新增定时任务。\n直接通过crontab命令查看当前用户的定时任务，出现使用Python代码新增的定时任务。\n3.3 修改定时任务 执行Python代码修改定时任务。\n直接通过crontab命令查看当前用户的定时任务，定时任务修改成功。\n3.4 删除定时任务 执行Python代码删除定时任务。\n直接通过crontab命令查看当前用户的定时任务，定时任务删除成功。\n","date":"2023-06-29T09:47:00+08:00","image":"https://euansu123.github.io/img/python.jpg","permalink":"https://euansu123.github.io/post/python_crontab/","title":"Python-crontab 定时任务"},{"content":"文章整理了JavaScript常用函数。\n过滤列表元素\u0026ndash;filter filter()方法创建一个通过条件的新数组。\nfilter 语法 var newArray = arr.filter(callbackFn(element, [index], [array]), context) // element 数组中当前正在处理的元素 // index【可选】 正在处理的元素在数组中的索引 // arrray【可选】 filter处理的数组 函数使用 const words = [\u0026#39;spray\u0026#39;, \u0026#39;limit\u0026#39;, \u0026#39;elite\u0026#39;, \u0026#39;exuberant\u0026#39;, \u0026#39;destruction\u0026#39;, \u0026#39;present\u0026#39;]; const result = words.filter(word =\u0026gt; word.length \u0026gt; 6); console.log(result); const result1 = words.filter(function (element,index,arr) { console.log(arr[index]) console.log(element) return element.length \u0026gt; 6 }, words); 函数输出\nArray [\u0026#34;exuberant\u0026#34;, \u0026#34;destruction\u0026#34;, \u0026#34;present\u0026#34;] Array [\u0026#34;exuberant\u0026#34;, \u0026#34;destruction\u0026#34;, \u0026#34;present\u0026#34;] \u0026#34;spray\u0026#34; \u0026#34;spray\u0026#34; \u0026#34;limit\u0026#34; \u0026#34;limit\u0026#34; \u0026#34;elite\u0026#34; \u0026#34;elite\u0026#34; \u0026#34;exuberant\u0026#34; \u0026#34;exuberant\u0026#34; \u0026#34;destruction\u0026#34; \u0026#34;destruction\u0026#34; \u0026#34;present\u0026#34; \u0026#34;present\u0026#34; 修改列表元素\u0026ndash;map map 语法 var newArray = arr.map(callbackFn(element, [index], [array]), context) // element 数组中当前正在处理的元素 // index【可选】 正在处理的元素在数组中的索引 // arrray【可选】 filter处理的数组 函数使用 const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x =\u0026gt; x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] const map2 = array1.map(function (element,index,arr) { console.log(arr[index]) console.log(element) return element * 2 }, array1); console.log(map2) 函数输出\nArray [2, 8, 18, 32] 1 1 4 4 9 9 16 16 Array [1, 4, 9, 16] 更新列表元素\u0026ndash;forEach forEach 语法 array.forEach(function(currentValue, index, arr)) # currentValue：函数当前处理的值 # index：当前值在列表中索引 # arr：被处理的列表 函数使用 let students = [\u0026#39;John\u0026#39;, \u0026#39;Sara\u0026#39;, \u0026#39;Jack\u0026#39;]; students.forEach(myFunction); function myFunction(item, index, arr) { arr[index] = \u0026#39;Hello \u0026#39; + item; } console.log(students); 函数输出\n[\u0026#34;Hello John\u0026#34;, \u0026#34;Hello Sara\u0026#34;, \u0026#34;Hello Jack\u0026#34;] 查找列表符合条件的第一个元素\u0026ndash;find find 语法 const index = arr.find(callback(element, index, arr),thisArg) // element 数组中当前正在处理的元素 // index【可选】 正在处理的元素在数组中的索引 // arrray【可选】 filter处理的数组 函数使用 let numbers = [1, 3, 4, 9, 8]; function isEven(element) { return element % 2 == 0; } let evenNumber = numbers.find(isEven); console.log(evenNumber); 函数输出\n4 查找列表符合条件的第一个元素的位置\u0026ndash;findIndex findIndex 语法 const index = arr.findIndex(callback(element, index, arr),thisArg) // element 数组中当前正在处理的元素 // index【可选】 正在处理的元素在数组中的索引 // arrray【可选】 filter处理的数组 函数使用 function isOdd(element) { return element % 2 !== 0; } let numbers = [2, 8, 1, 3, 4]; let firstOdd = numbers.findIndex(isOdd); console.log(firstOdd); 函数输出\n2 ","date":"2023-06-09T10:16:48+08:00","image":"https://euansu123.github.io/img/javascript.jpg","permalink":"https://euansu123.github.io/post/javascript_array_func/","title":"JavaScript列表常用函数"},{"content":"Django迁移报错问题记录 问题现象 变动模型后，执行migrate命令将模型变动应用于数据库时，出现如下报错：django.core.exceptions.FieldDoesNotExist。\n问题解决 首先查找了Component模型中name字段的应用情况，未发现该字段作为其他模型的外键。\n尝试先不删除Component模型的name字段，先应用模型中其他字段的变更，不报错，再次删除name字段，迁移数据库不报错。\n查看django生成的迁移文件，发现其修改联合索引的操作位于删除字段操作之后，尝试将修改联合索引的操作移动至删除字段之前，执行数据库迁移操作，不报错。\n# django模型迁移文件中的部分代码\tmigrations.RemoveField( model_name=\u0026#39;component\u0026#39;, name=\u0026#39;abnormal_nodes\u0026#39;, ), migrations.RemoveField( model_name=\u0026#39;component\u0026#39;, name=\u0026#39;name\u0026#39;, ), migrations.RemoveField( model_name=\u0026#39;component\u0026#39;, name=\u0026#39;normal_nodes\u0026#39;, ), migrations.RemoveField( model_name=\u0026#39;component\u0026#39;, name=\u0026#39;status\u0026#39;, ), migrations.RemoveField( model_name=\u0026#39;component\u0026#39;, name=\u0026#39;sum_nodes\u0026#39;, ), migrations.RemoveField( model_name=\u0026#39;component\u0026#39;, name=\u0026#39;updated_at\u0026#39;, ), migrations.RemoveField( model_name=\u0026#39;component\u0026#39;, name=\u0026#39;version\u0026#39;, ), migrations.AlterUniqueTogether( name=\u0026#39;component\u0026#39;, unique_together=set([(\u0026#39;cluster\u0026#39;, \u0026#39;cmpnt_name\u0026#39;)]), ), 问题分析 对比原有模型与变动后的模型，变动前后的模型中，对字段和联合索引均做了操作，Django根据模型变动生成的迁移文件中，对于字段的变动有新增、修改和删除，而对于联合索引的变动只有修改操作，因此应该是修改联合索引时，对联合索引的字段进行查找，而如上的操作则是查询不到的情况下出现的报错。\n# 变动前的模型 class Component(models.Model): cluster = models.ForeignKey(Cluster) name = models.CharField(default=\u0026#39;\u0026#39;, max_length=50) version = models.CharField(default=\u0026#39;\u0026#39;, max_length=50) sum_nodes = models.IntegerField(null=True) normal_nodes = models.IntegerField(null=True) abnormal_nodes = models.IntegerField(null=True) status = models.BooleanField(blank=True) updated_at = models.DateTimeField(null=True) class Meta: unique_together = (\u0026#34;cluster\u0026#34;, \u0026#34;name\u0026#34;) # 变动后的模型 class Component(models.Model): \u0026#34;\u0026#34;\u0026#34; 集群组件信息表 \u0026#34;\u0026#34;\u0026#34; cluster = models.ForeignKey(Cluster, db_index=True) cmpnt_name = models.CharField(max_length=50, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;组件名称\u0026#39;) cmpnt_version = models.CharField(max_length=50, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;组件版本\u0026#39;) extra_info = models.CharField(max_length=5000, default=\u0026#39;\u0026#39;) is_monitored = models.BooleanField(default=False, verbose_name=\u0026#39;是否可监控\u0026#39;) is_assigned = models.BooleanField(default=False, verbose_name=\u0026#39;是否可分配\u0026#39;) is_authorised = models.BooleanField(default=False, verbose_name=\u0026#39;是否可授权\u0026#39;) registed_by = models.CharField(max_length=50, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;组件注册用户\u0026#39;) registed_at = models.DateTimeField(auto_now=True, verbose_name=\u0026#39;组件注册时间\u0026#39;) updated_by = models.CharField(max_length=50, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;组件更新用户\u0026#39;) enabled_flag = models.BooleanField(default=True, verbose_name=\u0026#39;组件是否启用\u0026#39;) enabled_flag_updated_by = models.CharField(max_length=50, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;组件启用修改用户\u0026#39;) enabled_flag_updated_at = models.DateTimeField(null=True, verbose_name=\u0026#39;组件启用修改时间\u0026#39;) class Meta: unique_together = ((\u0026#34;cluster\u0026#34;, \u0026#34;cmpnt_name\u0026#34;)) 该问题的解决有两种方案： (1)迁移的操作分为两次，第一次只修改不涉及联合索引模型字段，同时修改原有的联合索引。 (2)修改迁移文件中联合索引和字段的变更顺序，在删除字段前先修改联合索引，然后执行字段的删除。\n","date":"2023-01-05T23:57:38+08:00","image":"https://euansu123.github.io/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E6%8A%A5%E9%94%99.png","permalink":"https://euansu123.github.io/post/django_migrate/","title":"Django 数据库迁移报错问题记录"},{"content":"序列化 序列化是指将对象转换成字节流，从而存储对象或将对象传输到内存、数据库或文件的过程，它的主要用途是保存对象的状态，以便能够在需要时重新创建对象，反向过程称为“反序列化”。\n序列化的工作原理 对象杯序列化成流，其中不仅包含数据，还包含对象类型的相关信息，如版本、区域性和程序集名称。 可以将此流中的内容存储在数据库、文件或内存中。\n序列化的用途 借助序列化，开发者可以保存对象的状态，并能在需要时重新创建对象，同时还能存储对象和交换数据。 通过序列化，开发者可以执行如下操作：通过 Web 服务将对象发送到远程应用程序、在域之间传递对象、以 XML 字符串的形式传递对象通过防火墙、跨应用程序维护安全性或用户专属信息。\n序列化的代码实现 Pickle Python提供了 pickle 模块来实现序列化。\n# coding=utf-8 import pickle dic = {\u0026#39;name\u0026#39;:\u0026#39;Bob\u0026#39;,\u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:88} # 序列化 s1 = pickle.dumps(dic) print(s1) # 反序列化 s2 = pickle.loads(s1) print(s2) 执行代码输出的结果为：\n(dp0 S\u0026#39;age\u0026#39; p1 I20 sS\u0026#39;score\u0026#39; p2 I88 sS\u0026#39;name\u0026#39; p3 S\u0026#39;Bob\u0026#39; p4 s. {\u0026#39;age\u0026#39;: 20, \u0026#39;score\u0026#39;: 88, \u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;} JSON 如果要在不同的编程语言之间传递对象，需要把对象序列化为标准格式，例如XML，但更好的方法是序列化为JSON格式，因为JSON就是一个字符串，可以被所有语言读取。\nJSON与Python数据类型的对应关系如下所示：\nJSON类型 Python类型 {} dict [] list \u0026ldquo;string\u0026rdquo; str 1234.56 int或float true/false True/False null None import json dic = {\u0026#39;name\u0026#39;:\u0026#39;Bob\u0026#39;,\u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:88} # 序列化 s1 = json.dumps(dic) print(type(s1)) print(s1) # 反序列化 s2 = json.loads(s1) print(type(s2)) print(s2) 执行代码输出的结果为：\n\u0026lt;type \u0026#39;str\u0026#39;\u0026gt; {\u0026#34;age\u0026#34;: 20, \u0026#34;score\u0026#34;: 88, \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;} \u0026lt;type \u0026#39;dict\u0026#39;\u0026gt; {u\u0026#39;age\u0026#39;: 20, u\u0026#39;score\u0026#39;: 88, u\u0026#39;name\u0026#39;: u\u0026#39;Bob\u0026#39;} ","date":"2022-12-27T11:57:38+08:00","image":"https://euansu123.github.io/img/python.jpg","permalink":"https://euansu123.github.io/post/serialization/","title":"序列化"},{"content":"Mysql编译安装能够根据需要设定参数，按照需求进行定制安装，并且安装的版本可以根据项目需要灵活选择，整体可配置弹性大。\n前提准备 下载 mysql 源码包 到 https://downloads.mysql.com/archives/community/ 下载对应版本的安装包，需要注意的是 mysql5.7 编译安装需要boost 库，可以在官网下载含 boost 的源码包。\n安装相关依赖包 sudo yum install -y gcc gcc-c++ cmake ncurses ncurses-devel bison wget openssl-devel.x86_64 创建 mysql 所需目录 mkdir /iddbs/mysql mkdir /iddbdata/3306/data mkdir /iddbdata/3306/binlog/ mkdir /iddbdata/3306/logs/ 编译安装 配置相关参数 cmake -DCMAKE_INSTALL_PREFIX=/iddbs/mysql -DMYSQL_DATADIR=/iddbdata/3306/data -DMYSQL_UNIX_ADDR=/iddbdata/3306/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_BOOST=boost # DCMAKE_INSTALL_PREFIX 指定MySQL程序的安装目录 # DMYSQL_DATADIR 数据文件目录 # DMYSQL_UNIX_ADDR socket文件路径 # DDEFAULT_CHARSET 指定服务器默认字符集，默认latin1 # DDEFAULT_COLLATION 指定服务器默认的校对规则，默认latin1_general_ci 源码编译安装 make \u0026amp; make install 准备 mysql 配置文件 # 准备my.cnf文件 [client] port=3305 socket=/iddbdata/3306/mysql.sock [mysqld] port=3306 server-id=1013306 basedir=/iddbs/mysql plugin-dir=/iddbs/mysql/lib/plugin datadir=/iddbdata/3306/data log-bin=/iddbdata/3306/binlog/bin-log pid-file=/iddbdata/3306/mysql.pid socket=/iddbdata/3306/mysql.sock relay-log=/iddbdata/3306/binlog/relay-log log-error=/iddbdata/3306/logs/mysql-error.log log_timestamps=system 初始化 mysql # 如果不加--initialize-insecure，会直接在前台输出密码 /iddbs/mysql/bin/mysqld --defaults-file=/iddbdata/3306/my.cnf --user=euansu --initialize-insecure 启动 mysql /iddbs/mysql/bin/mysqld_safe --defaults-file=/iddbdata/3306/my.cnf --user=euansu \u0026amp; 连接 mysql /iddbs/mysql/bin/mysql -uroot -S /iddbdata/3306/mysql.sock 设置 root 账户密码。\nset password for root@localhost = password(\u0026#34;mysql\u0026#34;); mysql 相关操作 # 设置mysql密码 set password for root@localhost = password(\u0026#34;mysql\u0026#34;); # 创建数据库 create database idbcdb; # 创建mysql用户 create user \u0026#39;euansu\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;euansu\u0026#39;; # 刷新权限 flush privileges; # 用户赋予mysql远程操作的所有权限 grant all privileges on *.* to euansu@\u0026#39;%\u0026#39;; # 查看用户euansu的权限域 show grants for euansu@\u0026#39;%\u0026#39;; ","date":"2022-08-07T15:07:57+08:00","image":"https://euansu123.github.io/img/mysql.jpg","permalink":"https://euansu123.github.io/post/mysql_source_code_compile/","title":"Mysql源码编译安装"},{"content":"文件读写 对磁盘文件的读写操作是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，因此读写文件就是请求操作系统打开一个文件对象，然后通过操作系统提供的接口从这个文件对象中读取数据或写入数据。\n读文件 读取文本文件 以读文件的模式打开一个文件对象，使用Python内置的 open() 函数，传入文件名和标示符。\n# 标示符 r 标识读 f = open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) 如果文件不存在，open() 函数会抛出一个 IOERROR 的错误。\n如果文件打开成功，调用 read() 方法可以一次性读取文件的全部内容。\nf = open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) file_detail = f.read() print file_detail 读取文件操作结束后，需要调用 close() 方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的\nf = open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) file_detail = f.read() print file_detail f.close() 读写文件的过程中有可能产生 IOERROR ，一旦出错，后面的 close() 操作就不会被执行。因此，为了保证无论是否报错都需要在结束的时候调用 close() 操作关闭文件，可以使用 try...finally 来实现：\ntry: f = open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) print(f.read()) finally: if f: f.close() Python 引入 with 语句也能够达到在文件操作结束后调用 close() 函数的目的：\nwith open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: print(f.read()) 调用 read() 会一次性读取文件的全部内容，如果文件过大，可能会导致系统资源过载，从而导致函数执行异常，因此可以通过反复掉用 read(size)， 读取 size 字节的内容：\nf = open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) file_detail = f.read(8) file_detail2 = f.read(8) print file_detail print \u0026#39;--------\u0026#39; print file_detail2 f.close() 除指定 size 的方式以外，还可通过 readline() 和 readlines() 的方法，readline() 可以每次读取一行内容，readlines()一次读取所有内容并按行返回一个list。\nwith open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: file_line = f.readline() file_lines = f.readlines() print file_line print file_lines 读取二进制文件 如图片、视频等都是二进制文件，使用 rb 标示符进行读取操作。\nwith open(\u0026#39;D:\\Code\\python27demo\\\\auther.jpg\u0026#39;, \u0026#39;rb\u0026#39;) as f: file = f.read() 文件编码 如果要读取非 UTF-8 编码格式的文本文件，需要给 open()函数传入 encoding 参数，例如，读取 GBK 编码的文件：\n# python2 import io with io.open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;,encoding=\u0026#39;gbk\u0026#39;) as f: file = f.read() print file # python3 with open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: file = f.read() print(file) 写文件 覆盖操作 写文件和读文件操作是一致的，唯一的区别是 open() 函数时，传入标识符 w 或 wb 表示写文本文件或写二进制文件。\nwith open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;192.168.110.30\u0026#39;) with open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: file = f.read() print file 追加操作 以 w 模式写入文件时，如果文件中存在其他内容，会直接进行覆盖，如果希望追加文件到末尾，可以通过a 模式，进行追加写入操作。\nwith open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: file = f.read() print file with open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;a\u0026#39;) as f: f.write(\u0026#39;192.168.110.30\\n\u0026#39;) with open(\u0026#39;D:\\Code\\python27demo\\zookeeper.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: file = f.read() print file ","date":"2022-07-26T11:57:38+08:00","image":"https://euansu123.github.io/img/python.jpg","permalink":"https://euansu123.github.io/post/python_open_file/","title":"文件读写"},{"content":"环境说明 # python 3.7.8 # django 2.1 # mysql 5.7.36 Django 安装 # 使用pip命令时-i指定国内源地址，例如: pip install -i https://pypi.mirrors.ustc.edu.cn/simple/ django==2.1 # django==2.1指定下载2.1版本的django 创建 Django 项目 创建 Django 项目结构 # 创建django项目的目录，执行django-admin startproject xxx创建项目，例如： django-admin startproject mysite 创建 APP 每个 Django 项目中可以创建多个子应用（APP），每个子应用之间结构相互独立，共享项目资源。\n# 执行如下命令创建APP python manage.py startapp login 编写路由 这里的路由是浏览器输入的 url 路径，经由 Django 服务器响应解析后进行转发，Django 的路由都写在 urls.py 文件中，urls.py 编写方法如下：\n编写视图函数 Django 路由转发给是凸函数进行处理，视图函数也即用来处理业务逻辑的方法，一般写在 views.py 文件中，views.py 编写方法如下：\n注意：\n视图函数的参数 request 不能更改，因为 Django 使用 request 封装了网络请求的所有内容。 return 不能直接返回字符串，必须由 HttpResponse 封装后，才可以被 Http 协议识别，也可使用 JsonResponse 封装后返回。 运行 Django 项目 # 使用python运行Django项目中的manage.py文件 # 执行该步时，需要进入项目目录中 python manage.py runserver [127.0.0.1:9000] 直接访问 127.0.0.1:9000 ，页面显示为 not found，这是因为我们没有编写执行 / 的路由，所以 Django 无法对 127.0.0.1:9000 进行处理。\n加上编写的 /index/ 路由访问，就能够查看刚才所编写的视图函数返回的结果，至此，一个简单的 Django 项目就启动成功了。\n返回 HTML 页面 创建 templates 目录用于存放 HTML 文件：\n└── mysite\r├── login\r├── manage.py\r├── mysite\r└── templates 在 settings.py 修改 TEMPLATES 中的 DIRS 配置，DIRS 中定义了模板目录列表，Django 会在这些目录中寻找对应的 HTML 页面。\nTEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR,\u0026#39;templates\u0026#39;)], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] 在 templates 目录下编写 HTML 文件。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 style=\u0026#34;background-color: antiquewhite;color: black\u0026#34;\u0026gt;Hello Django!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 修改对应的视图函数。\ndef index(request): return render(request, \u0026#39;index.html\u0026#39;) 页面访问，出现 HTML 页面的响应。\n使用静态文件 创建 static 目录用以存放静态文件：\n└── mysite\r├── db.sqlite3\r├── login\r├── manage.py\r├── mysite\r├── static\r└── templates 在 settings.py 新增静态文件的配置路径，STATICFILES_DIRS 中定义了静态文件的目录列表，Django 会在这些目录中寻找对应的静态文件。\nSTATIC_URL = \u0026#39;/static/\u0026#39; STATICFILES_DIRS = [ os.path.join(BASE_DIR, \u0026#39;static\u0026#39;) ] 这里的 STATIC_URL 指的是在浏览器中访问静态文件的前缀配置，在 static 目录中存放一个 icon.jpg ，访问 localhost:8000/static/icon.jpg 即可查看图片。\n在 static 目录中新增 first.js 文件。\nfunction clickFuc(){ alert(\u0026#39;JS文件的响应！\u0026#39;) } 在上方所创建的 index.html 中引入 first.js，并引用 clickFuc 方法。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 style=\u0026#34;background-color: antiquewhite;color: black\u0026#34;\u0026gt;Hello Django!\u0026lt;/h1\u0026gt; \u0026lt;button onclick=\u0026#34;clickFuc()\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;../static/first.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 访问 localhost:8000/index/，点击按钮就能够看到 JS 文件中方法的响应。\n接收页面输入的数据 修改 index.html 文件，使得能够通过页面输入数据。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;用户输入：\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;/index/\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt; 密码：\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 修改视图函数。\ndef index(request): if request.method == \u0026#39;POST\u0026#39;: username = request.POST.get(\u0026#39;username\u0026#39;) password = request.POST.get(\u0026#39;password\u0026#39;) print(username, password) return render(request, \u0026#39;index.html\u0026#39;) 回到前端页面输入用户名和密码时，显示CSRF 跨域问题，这是因为 Django 的跨站请求保护机制，在 HTML 文件中加入一行 {% csrf_token %}。\n刷新页面后，在页面再次输入，后端即可接收到来自前端的数据。\n返回动态页面 修改 index.html ，使之能够接收来自 Django 服务器处理后的数据。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;用户输入：\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;/index/\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; {% csrf_token %} 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt; 密码：\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;h1\u0026gt;用户展示：\u0026lt;/h1\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;用户名\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;密码\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {% for item in data %} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{ item.user }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ item.password }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 修改对应的视图函数。\ndef index(request): user_list = [] if request.method == \u0026#39;POST\u0026#39;: username = request.POST.get(\u0026#39;username\u0026#39;) password = request.POST.get(\u0026#39;password\u0026#39;) temp = {\u0026#39;user\u0026#39;: username, \u0026#39;password\u0026#39;: password} user_list.append(temp) return render(request, \u0026#39;index.html\u0026#39;, {\u0026#39;data\u0026#39;: user_list}) 在页面输入用户名和密码，就能够在下方的表格中进行展示。\n使用数据库 在 settings.py 中的 INSTALLED_APPS 中加入创建的应用。\nINSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;login\u0026#39; ] 在 settings.py 中的 DATABASES 配置数据库，这里 Django 配置了 sqlite 数据库暂时不做修改。\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: os.path.join(BASE_DIR, \u0026#39;db.sqlite3\u0026#39;), } } 编辑 login 应用下的 models.py 文件。\nclass UserInfo(models.Model): user = models.CharField(max_length=32) password = models.CharField(max_length=32) 在终端执行数据库迁移命令。\n# 生成迁移文件 python.exe .\\manage.py makemigrations # 应用迁移文件到数据库生成库表 python.exe .\\manage.py migrate 修改视图函数从数据库读写数据。\ndef index(request): if request.method == \u0026#39;POST\u0026#39;: username = request.POST.get(\u0026#39;username\u0026#39;) password = request.POST.get(\u0026#39;password\u0026#39;) # 将数据保存到数据库 UserInfo.objects.create(user=username, password=password) # 从数据库中读取所有数据，注意缩进 user_list = UserInfo.objects.all() return render(request, \u0026#39;index.html\u0026#39;, {\u0026#39;data\u0026#39;: user_list}) 即使再次刷新页面，也不会出现上面数据消失的情况，也即实现了数据的持久化操作。\n","date":"2022-07-25T11:57:38+08:00","image":"https://euansu123.github.io/img/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8CDjango%E9%A1%B9%E7%9B%AE.png","permalink":"https://euansu123.github.io/post/django_quick_start/","title":"Django入门记录"},{"content":"Django 数据库的迁移通过 makemigrations 和 migrate 命令实现，其中 makemigrations 基于 models.py 的变更生成新的 migrations 文件， migrate 把 migrations文件应用到数据库，也可以取消已应用的 migrations 文件。\nDjango 的数据库迁移操作 在 app 目录下的 models.py 文件中新增 class。\n执行 makemigrations 命令生成迁移文件。\n使用 migrate 应用迁移文件。\nDjango 迁移数据库后，会在 django_migrations 表中做记录，查询该表发现应用 myblog 最新的迁移 0002_test 已经被应用。\n使用 migrate 命令实现数据迁移的回滚 使用 migrate 回滚最近一次迁移操作 应用 myblog 共有两次迁移操作，分别是：0001_initial和0002_test，使用 migrate 命令指定应用 myblog 以及 0001。\npython manage.py migrate myblog 0001 命令执行成功后，查询 django_migrations 表的记录，此时数据库表中仅有 0001 的记录，迁移回滚操作成功。\n使用 migrate 回滚应用所有的迁移操作 执行 makemigrations和 migrate 命令，执行数据库的迁移操作。\n执行完成后，django_migrations 表出现 0002 迁移的记录。\n使用 migrate 命令指定应用 myblog ，并指定要回滚的操作为 zero。\npython manage.py migrate zero 查看 django_migrations 表，无应用 myblog 的迁移记录，数据库迁移回滚操作成功。\n","date":"2022-07-21T19:10:00+08:00","image":"https://euansu123.github.io/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E5%9B%9E%E6%BB%9A.png","permalink":"https://euansu123.github.io/post/django_migrate_cancel/","title":"Django 数据库迁移操作的回滚"},{"content":"Oracle 数据库安装及连接操作。\n准备工作 下载 Oracle 19c 安装包，下载地址：https://www.oracle.com/database/technologies/oracle-database-software-downloads.html#19c\n下载 Oracle 19c 预安装包，下载地址：http://yum.oracle.com/repo/OracleLinux/OL7/latest/x86_64/getPackage/oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm\n安装过程 上传 rpm 包到服务器。\n安装 Oracle 预安装rpm包。\nyum -y localinstall oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm 安装 Oracle 安装rpm包。\nyum -y localinstall oracle-database-ee-19c-1.0-1.x86_64.rpm 配置 Oracle 环境。\n/etc/init.d/oracledb_ORCLCDB-19c configure 配置过程执行结束后，查询 Oracle 进程，Oracle 进程存在表示安装完成。\n创建 Oracle 用户，并配置 Orace 用户的环境变量。\n执行 sqlplus / as sysdba 校验 Oracle 数据库是否启动成功。\n使用连接工具测试连接是否成功。\nOracle 数据库启停操作 /etc/init.d/oracledb_ORCLCDB-19c start|stop|restart|configure|delete Oracle 数据库简单操作 创建表空间\ncreate tablespace tab_name datafile \u0026#39;path\u0026#39; size n [autoextend on next n1 maxsize m /of] [permanent] [extent management local/dictionary]; # tab_name 表空间的名字 # path 数据文件路径 # size n 指定数据文件的大小 create tablespace euansu datafile \u0026#39;/home/oracle/data\u0026#39; size 100M; 创建临时表空间\ncreate temporary tablespace temp_name tempfile \u0026#39;path\u0026#39; size n; # tempname 表空间的名字 # path 临时表空间数据文件的位置 # size m 表示临时表空间的大小 create temporary tablespace euansu_temp tempfile \u0026#39;/home/oracle/euansu_temp\u0026#39; size 10M; 创建用户\ncreate user euansu identified by \u0026#34;suwenhui123\u0026#34; default tablespace euansu temporary tablespace euansu_temp; # tablespace 表空间 # temporary tablespace 临时表空间 # 创建用户时会报65096的错误，执行如下语句即可： alter session set \u0026#34;_ORACLE_SCRIPT\u0026#34;=true; Python连接Oracle 安装 cx_Oracle 第三方库 最新 cx_Oracle 并不支持 Python2.7，这里下载支持 Python2.7 的7.3.0 版本，下载地址：https://files.pythonhosted.org/packages/5e/e3/cfd4f413f8d47dd2aee09273d9bb3ee6aa7384e0a04e191d703c2199eb93/cx_Oracle-7.3.0.tar.gz\n# 解压 cx_Oracle 源码包 tar -zxvf cx_Oracle-7.3.0.tar.gz # 安装 cx_Oracle 第三方库 python2.7 setup.py install 安装 Oracle Instant Client 通过 python 连接 oracle 需要使用 cx_Oracle 第三方库，要求主机提前安装 Oracle Instant Client，否则连接 Oracle 会报如下错误。\n下载 Oracle Instant Client 下载地址：https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html，下载对应版本的 Oracle Instant Client包即可。\n创建 Oracle Instant Clinet 所需目录 sudo mkdir -p /opt/oracle sudo mv instantclient-basic-linux.x64-21.7.0.0.0dbru.zip /opt/oracle/ cd /opt/oracle sudo unzip instantclient-basic-linux.x64-21.7.0.0.0dbru.zip 安装系统 libaio 包 sudo yum install libaio 创建 Instant Client 的 .so 文件依赖 sudo sh -c \u0026#34;echo /opt/oracle/instantclient_21_7 \u0026gt; /etc/ld.so.conf.d/oracle-instantclient.conf\u0026#34; sudo ldconfig 添加 Instant Clinet 的环境变量 export LD_LIBRARY_PATH=/opt/oracle/instantclient_21_7:$LD_LIBRARY_PATH 测试连接 Python 连接 Oracle 封装代码 import cx_Oracle class OracleApi(object): def __init__(self, host, port, user, password, instant): self.host = host self.port = port self.user = user self.password = password self.instant = instant def connect(self): self.conn = cx_Oracle.connect(self.user, self.password, \u0026#39;%s:%s/%s\u0026#39; % (self.host, self.port,self.instant)) self.cursor = self.conn.cursor() def close(self): self.cursor.close() self.conn.close() def get_one(self, sql, params=()): result = None try: self.connect() self.cursor.execute(sql, params) result = self.cursor.fetchone() self.close() except Exception, e: print e.message return result def get_all(self, sql): list = () try: self.connect() self.cursor.execute(sql) list = self.cursor.fetchall() self.close() except Exception, e: print e.message return list ","date":"2022-07-15T09:47:00+08:00","image":"https://euansu123.github.io/img/oracle.jpg","permalink":"https://euansu123.github.io/post/oracle_19c_operate/","title":"Oracle 19c 安装使用记录"},{"content":"导入Jpype第三方包，驱动jar包连接数据库。\n前提准备 # 下载第三方包 pip install -i [https://pypi.mirrors.ustc.edu.cn/simple/] jpype1 # 导入第三方包 import jpype.imports from jpype import dbapi2 # 加载jar包 jpype.startJVM(classpath=\u0026#39;D:/Enviroment/Java/jar/mysql-connector-java-8.0.29/mysql-connector-java-8.0.29.jar\u0026#39;) # 数据库配置信息 HOST = \u0026#39;101.xx.xx.xx\u0026#39; PORT = \u0026#39;3306\u0026#39; DATABASE = \u0026#39;db_test\u0026#39; USERNAME = \u0026#39;xxxx\u0026#39; PASSWORD = \u0026#39;xxxx\u0026#39; 构造 MySQL 类 class MySqlDB(object): def __init__(self, host=HOST, port=PORT, db=DATABASE, user=USERNAME, passwd=PASSWORD): self.conn_url = \u0026#34;jdbc:mysql://{host}:{port}/{db}?characterEncoding=UTF-8\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;useSSL=false\u0026#34;.format(host=host, port=port, db=db) self.driver_args = {\u0026#34;user\u0026#34;: user, \u0026#34;password\u0026#34;: passwd} self.driver = \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; def connect(self): self.conn = dbapi2.connect(self.conn_url, driver=self.driver, driver_args=self.driver_args) self.cursor = self.conn.cursor() def close(self): self.cursor.close() self.conn.close() def get_all(self, sql): \u0026#34;\u0026#34;\u0026#34; 拿取所有的结果 :param sql: :return: \u0026#34;\u0026#34;\u0026#34; self.cursor.execute(sql) result = self.cursor.fetchall() return result def get_one(self, sql): \u0026#34;\u0026#34;\u0026#34; 拿取第一个结果 :param sql: :return: \u0026#34;\u0026#34;\u0026#34; self.cursor.execute(sql) result = self.cursor.fetchone() return result 连接操作 查询数据库下的表 def get_tables(): mysql_obj = MySqlDB() mysql_obj.connect() list = mysql_obj.get_all(\u0026#34;show tables;\u0026#34;) return list 查询数据库表的信息 def get_tableinfo(table): mysql_obj = MySqlDB() mysql_obj.connect() sql = \u0026#34;\u0026#34;\u0026#34;select * from {table};\u0026#34;\u0026#34;\u0026#34;.format(table=table) result = mysql_obj.get_all(sql) return result ","date":"2022-07-14T09:47:00+08:00","image":"https://euansu123.github.io/img/python.jpg","permalink":"https://euansu123.github.io/post/python_run_jar/","title":"Python 使用 jar 包操作数据库"},{"content":"PostgreSQL 被业界誉为“世界上最先进的开源关系型数据库”，虽然 PostgreSQL 是关系型数据库，但其也支持 NoSQL 数据类型（JSON/XML/hstore），并且性能甚至超过了 MongoDB。\nPGSQL 操作 PGSQL CLI # pgsql部署执行执行如下操作 sudo su - postgres psql PGSQL 客户端连接 # 使用客户端连接使用 psql -h 133.0.120.49 -p 18921 --username=flink_cdc --password PGSQL 语句操作 创建用户\ncreate user \u0026#34;suwh\u0026#34; with password \u0026#39;suwenhui@2022\u0026#39;; 创建库\ncreate database suwh with owner suwh; 获取pgsql所有的库\nselect * from pg_database; 获取pgsql所有的表\nSELECT tablename FROM pg_tables WHERE tablename NOT LIKE\u0026#39;pg%\u0026#39; AND tablename NOT LIKE\u0026#39;sql_%\u0026#39; ORDER BY tablename; 创建pgsql表\n# 创建表 CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); # 插入数据 INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1, \u0026#39;Allen\u0026#39;, 25, \u0026#39;Texas\u0026#39;, 10000); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (3, \u0026#39;euansu\u0026#39;, 25, \u0026#39;Texas\u0026#39;, 10000.9); 查询pgsql表结构\nSELECT A.ordinal_position, A.column_name, CASE A.is_nullable WHEN \u0026#39;NO\u0026#39; THEN 0 ELSE 1END AS is_nullable, A.data_type, coalesce(A.character_maximum_length, A.numeric_precision, -1) as length, B.COMMENT, CASE WHEN length(B.attname) \u0026gt; 0 THEN 1 ELSE 0 END AS is_pk FROM information_schema.columns A LEFT JOIN ( SELECT pg_attribute.attname, col_description ( pg_attribute.attrelid, pg_attribute.attnum ) AS COMMENT FROM pg_index, pg_class, pg_attribute WHERE pg_class.oid = \u0026#39;company\u0026#39;::regclass AND pg_index.indrelid = pg_class.oid AND pg_attribute.attrelid = pg_class.oid AND pg_attribute.attnum = ANY(pg_index.indkey) ) B ON A.column_name = b.attname WHERE A.table_schema = \u0026#39;public\u0026#39; AND A.table_name = \u0026#39;company\u0026#39; ORDER BY ordinal_position ASC; PGSQL 数据类型 名字 别名 描述 bigint int8 有符号8字节整数 bigserial serial8 自增8字节整数 bit [ (n) ] 定长位串 bit varying [ (n) ] varbit 可变长位串 boolean bool 逻辑布尔值(真/假) box 平面上的矩形 bytea 二进制数据(\u0026ldquo;字节数组\u0026rdquo;) character varying [(n)] varchar [(n)] 可变长字符串 cidr IPv4 或 IPv6 网络地址 circle 平面上的圆 date 日历日期(年, 月, 日) double precision float8 双精度浮点数(8字节) inet IPv4 或 IPv6 主机地址 integer int, int4 有符号 4 字节整数 interval [ fields ] [ (p) ] 时间间隔 line 平面上的无限长直线 lseg 平面上的线段 macaddr MAC (Media Access Control)地址 money 货币金额 numeric [ (p, s) ] decimal [ (p, s) ] 可选精度的准确数值数据类型 path 平面上的几何路径 point 平面上的点 polygon 平面上的封闭几何路径 real float4 单精度浮点数(4 字节) smallint int2 有符号 2 字节整数 smallserial serial2 自增 2 字节整数 serial serial4 自增 4 字节整数 text 可变长字符串 time [ (p) ] [ without time zone ] 一天中的时刻(无时区) time [ (p) ] with time zone timetz 一天中的时刻，含时区 timestamp [ (p) ] [ without time zone ] 日期与时刻(无时区) timestamp [ (p) ] with time zone timestamptz 日期与时刻，含时区 tsquery 文本检索查询 tsvector 文本检索文档 txid_snapshot 用户级别的事务ID快照 uuid 通用唯一标识符 xml XML 数据 json JSON 数据 Python 连接 PGSQL # 配置的用户 suwh 无数据库。 conn = psycopg2.connect(host=\u0026#39;172.21.3.82\u0026#39;, port=\u0026#39;5432\u0026#39;, user=\u0026#39;suwh\u0026#39;, password=\u0026#39;suwenhui@2022\u0026#39;) 给用户 suwh 创建库后，正常连接。\nPython 连接 PGSQL 报错 （1）问题现象\nSCRAM authentication requires libpq version 10 or above。\n（2）问题结论\nlibpq 包版本低于10版本，升级 libpq 包版本，使用最新的 libpq.so 包替换原有的 libpq.so 包。\n","date":"2022-07-13T09:47:00+08:00","image":"https://euansu123.github.io/img/postgres-logo.png","permalink":"https://euansu123.github.io/post/python_connect_pgsql/","title":"PGSQL 使用记录"},{"content":" LDAP是一个为查询、浏览和搜索而优化的专业分布式数据库，它成树状结构组织数据，类似于Linux/Unix系统中的文件目录一样。 目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好像它的名字一样，目录服务是由目录数据库和一套访问协议组成的系统。\n安装 openldap yum安装相关包\nsudo yum install -y openldap openldap-clients openldap-servers 复制默认配置到指定路径下\nsudo cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG 授权给yum安装时创建的ldap用户\nsudo chown -R ldap /var/lib/ldap/DB_CONFIG 启动ldap服务\n# 启动服务\rsudo systemctl start slapd\rsudo systemctl enable slapd\r# 查看运行状态\rsudo systemctl status slapd 修改 ldap 配置 生成管理员密码\n# sudo slappasswd -s 123456\r{SSHA}HHQ/x47AaijvK8wGhmAexBNgrx+ZDbF2 修改ldap的密码配置\n# 编辑文件如下 vim changepwd.ldif\rdn: olcDatabase={0}config,cn=config\rchangetype: modify\radd: olcRootPW\rolcRootPW: {SSHA}HHQ/x47AaijvK8wGhmAexBNgrx+ZDbF2\r# 执行如下命令，将密码配置应用于ldap\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f changepwd.ldif 导入ldap基本的schema文件。\n# 共计12个schema文件需要导入\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/collective.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/corba.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/duaconf.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/dyngroup.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/java.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/misc.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/openldap.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/pmi.ldif\rsudo ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/ppolicy.ldif 修改ldap的域名。\n# 修改域名 vim changedomain.ldif\rdn: olcDatabase={1}monitor,cn=config\rchangetype: modify\rreplace: olcAccess\rolcAccess: {0}to * by dn.base=\u0026#34;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\u0026#34; read by dn.base=\u0026#34;cn=admin,dc=euansu,dc=cn\u0026#34; read by * none\rdn: olcDatabase={2}hdb,cn=config\rchangetype: modify\rreplace: olcSuffix\rolcSuffix: dc=euansu,dc=cn\rdn: olcDatabase={2}hdb,cn=config\rchangetype: modify\rreplace: olcRootDN\rolcRootDN: cn=admin,dc=euansu,dc=cn\rdn: olcDatabase={2}hdb,cn=config\rchangetype: modify\rreplace: olcRootPW\rolcRootPW: {SSHA}HHQ/x47AaijvK8wGhmAexBNgrx+ZDbF2\rdn: olcDatabase={2}hdb,cn=config\rchangetype: modify\radd: olcAccess\rolcAccess: {0}to attrs=userPassword,shadowLastChange by dn=\u0026#34;cn=admin,dc=euansu,dc=cn\u0026#34; write by anonymous auth by self write by * none\rolcAccess: {1}to dn.base=\u0026#34;\u0026#34; by * read\rolcAccess: {2}to * by dn=\u0026#34;cn=admin,dc=euansu,dc=cn\u0026#34; write by * read\r# 执行如下命令将域名应用于ldap\rsudo ldapmodify -Y EXTERNAL -H ldapi:/// -f changedomain.ldif 启用memberof功能\n# 编写文件 vim add-memberof.ldif\rdn: cn=module{0},cn=config\rcn: modulle{0}\robjectClass: olcModuleList\robjectclass: top\rolcModuleload: memberof.la\rolcModulePath: /usr/lib64/openldap\rdn: olcOverlay={0}memberof,olcDatabase={2}hdb,cn=config\robjectClass: olcConfig\robjectClass: olcMemberOf\robjectClass: olcOverlayConfig\robjectClass: top\rolcOverlay: memberof\rolcMemberOfDangling: ignore\rolcMemberOfRefInt: TRUE\rolcMemberOfGroupOC: groupOfUniqueNames\rolcMemberOfMemberAD: uniqueMember\rolcMemberOfMemberOfAD: memberOf\r# 编写文件 vim refint1.ldif\rdn: cn=module{0},cn=config\radd: olcmoduleload\rolcmoduleload: refint\r# 编写文件 vim refint2.ldif\rdn: olcOverlay=refint,olcDatabase={2}hdb,cn=config\robjectClass: olcConfig\robjectClass: olcOverlayConfig\robjectClass: olcRefintConfig\robjectClass: top\rolcOverlay: refint\rolcRefintAttribute: memberof uniqueMember manager owner\r# 依次执行如下命令应用配置\rsudo ldapadd -Q -Y EXTERNAL -H ldapi:/// -f add-memberof.ldif\rsudo ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f refint1.ldif\rsudo ldapadd -Q -Y EXTERNAL -H ldapi:/// -f refint2.ldif 新增ldap组织\n#编写文件 vim base.ldif\rdn: dc=euansu,dc=cn\robjectClass: top\robjectClass: dcObject\robjectClass: organization\ro: Company\rdc: euansu\rdn: cn=admin,dc=euansu,dc=cn\robjectClass: organizationalRole\rcn: admin\rdn: ou=People,dc=euansu,dc=cn\robjectClass: organizationalUnit\rou: People\rdn: ou=Group,dc=euansu,dc=cn\robjectClass: organizationalRole\rcn: Group\r# 执行命令，应用配置\rsudo ldapadd -x -D cn=admin,dc=euansu,dc=cn -W -f base.ldif 安装 phpldapadmin LDAP网页服务 安装phpldapadmin包。\nsudo yum install -y phpldapadmin\r# 如果没有找到安装包，执行如下操作更新yum源，重新安装\rsudo yum localinstall http://rpms.famillecollet.com/enterprise/remi-release-7.rpm 修改LDAP配置文件。\n# 放开外部ip的访问 sudo vim /etc/httpd/conf.d/phpldapadmin.conf\r# 其中192.168.1.3是物理主机的ip\rAlias /phpldapadmin /usr/share/phpldapadmin/htdocs\rAlias /ldapadmin /usr/share/phpldapadmin/htdocs\r\u0026lt;Directory /usr/share/phpldapadmin/htdocs\u0026gt;\r\u0026lt;IfModule mod_authz_core.c\u0026gt;\r# Apache 2.4\rRequire all granted\r\u0026lt;/IfModule\u0026gt;\r\u0026lt;IfModule !mod_authz_core.c\u0026gt;\r# Apache 2.4\rOrder Deny,Allow\rDeny from all\rAllow from 127.0.0.1\rAllow from ::1\rAllow from 192.168.1.3\r\u0026lt;/IfModule\u0026gt;\r\u0026lt;/Directory\u0026gt;\r# 修改文件，更改phpldapadmin的登录方式 sudo vim /etc/phpldapadmin/config.php\r# 注释398行，放开387行\r$servers-\u0026gt;setValue(\u0026#39;login\u0026#39;,\u0026#39;attr\u0026#39;,\u0026#39;cn\u0026#39;);\r# 放开460行的注释，修改为如下\r$servers-\u0026gt;setValue(\u0026#39;login\u0026#39;,\u0026#39;anon_bind\u0026#39;,false);\r# 找到519行,设置用户属性的唯一性\r$servers-\u0026gt;setValue(\u0026#39;unique\u0026#39;,\u0026#39;attrs\u0026#39;,array(\u0026#39;mail\u0026#39;,\u0026#39;uid\u0026#39;,\u0026#39;uidNumber\u0026#39;,\u0026#39;cn\u0026#39;,\u0026#39;sn\u0026#39;)) 重启Apache服务。\n# 重启Apache服务\rsudo systemctl start httpd sudo systemctl enable httpd 访问页面。\n输入之前的账号：cn=admin,dc=euansu,dc=cn，进行登录。\n","date":"2021-12-26T09:47:00+08:00","image":"https://euansu123.github.io/img/p2608503691.jpg","permalink":"https://euansu123.github.io/post/ldap_tutorial/","title":"LDAP操作记录"},{"content":"记录了Python的网络请求实现与虚拟环境。\nPython 网络请求 这里使用 Python 的第三方库 requests 实现网络请求。\nrequests 有以下功能特性，几乎涵盖了当今 web 服务的需求，例：\n浏览器式的 SSL 验证； 身份认证； 带持久 Cookie 的会话； 流下载； 文件分块上传； HTTP 请求 HTTP 请求基本概念 一个HTTP请求由三部分构成：\n请求行 请求头： 请求正文 requests 方法实践 Get 请求 发送 Get 请求的 API 为：\nrequests.get(url, params=None, **kwargs) 使用 requests 发送 get 请求：\nimport requests get_response1 = requests.get(\u0026#39;https://api.github.com/events\u0026#39;) 部分情况下，URL 会携带参数，例如 https://segmentfault.com/blogs?page=2 ，这个 URL 有一个参数 page ，值为 2 ，requests 提供了 params 关键字参数，允许我们以字典的形式来提供这些参数：\nimport requests request_obj = requests.get(\u0026#39;https://segmentfault.com/blogs\u0026#39;,params={\u0026#39;page\u0026#39;:2,\u0026#39;age\u0026#39;:None}) print(request_obj.url) # 输出：https://segmentfault.com/blogs?page=2 # 注意：字典中为None的内容不会被添加到url上 Post 请求 发送 Post 请求的 API 为：\nrequests.post(url, data=None, json=None, **kwargs) 使用 requests 发送 post 请求\nimport requests request_obj = requests.post(\u0026#34;http://httpbin.org/post\u0026#34;) 通常，在发送 POST 请求时还会附上数据，比如发送编码为表单形式的数据或编码为 JSON 形式的数据，这时，我们可以使用 Requests 提供的 data 或 json 参数。\n发送编码为表单形式的数据\nimport requests payload = {\u0026#39;page\u0026#39;: 1, \u0026#39;per_page\u0026#39;: 10} request_obj = requests.post(\u0026#34;http://httpbin.org/post\u0026#34;, data=payload) 查看输出\n\u0026gt;\u0026gt;\u0026gt; print(request_obj.text) { \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: { \u0026#34;page\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;per_page\u0026#34;: \u0026#34;10\u0026#34; }, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Content-Length\u0026#34;: \u0026#34;18\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;python-requests/2.28.1\u0026#34;, \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;Root=1-62bd0db7-2705162709bce09a0ee24c31\u0026#34; }, \u0026#34;json\u0026#34;: null, \u0026#34;origin\u0026#34;: \u0026#34;222.90.10.252\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/post\u0026#34; } 发送编码为 JSON 格式的数据\n使用 data 参数也可发送 JSON 格式的数据。\nimport json import requests payload = {\u0026#39;page\u0026#39;: 1, \u0026#39;per_page\u0026#39;: 10} requests_obj = requests.post(\u0026#34;http://httpbin.org/post\u0026#34;, data=json.dumps(payload)) 查看输出结果：\n\u0026gt;\u0026gt;\u0026gt; print(requests_obj.text) { \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;{\\\u0026#34;page\\\u0026#34;: 1, \\\u0026#34;per_page\\\u0026#34;: 10}\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: {}, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Content-Length\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;python-requests/2.28.1\u0026#34;, \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;Root=1-62bd0e89-0bd2b1a02b9fcf7a40d8f479\u0026#34; }, \u0026#34;json\u0026#34;: { \u0026#34;page\u0026#34;: 1, \u0026#34;per_page\u0026#34;: 10 }, \u0026#34;origin\u0026#34;: \u0026#34;222.90.10.252\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/post\u0026#34; } 使用 data 参数传递编码为 JSON 格式的数据，需要对dict编码，等价于下面使用 json 参数直接传递 dict 的方式：\nimport requests payload = {\u0026#39;page\u0026#39;: 1, \u0026#39;per_page\u0026#39;: 10} requests_obj = requests.post(\u0026#34;http://httpbin.org/post\u0026#34;, json=payload) 查看结果输出：\n\u0026gt;\u0026gt;\u0026gt; print(requests_obj.text) { \u0026#34;args\u0026#34;: {}, \u0026#34;data\u0026#34;: \u0026#34;{\\\u0026#34;page\\\u0026#34;: 1, \\\u0026#34;per_page\\\u0026#34;: 10}\u0026#34;, \u0026#34;files\u0026#34;: {}, \u0026#34;form\u0026#34;: {}, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;*/*\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Content-Length\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;httpbin.org\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;python-requests/2.28.1\u0026#34;, \u0026#34;X-Amzn-Trace-Id\u0026#34;: \u0026#34;Root=1-62bd0f43-197076e340098e371a43fc3c\u0026#34; }, \u0026#34;json\u0026#34;: { \u0026#34;page\u0026#34;: 1, \u0026#34;per_page\u0026#34;: 10 }, \u0026#34;origin\u0026#34;: \u0026#34;222.90.10.252\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://httpbin.org/post\u0026#34; } 请求头 一些 Http 请求需要构造请求头，可以使用 dict 给 headers 传递参数实现，如下：\nimport requests url = \u0026#39;http://httpbin.org/post\u0026#39; payload = {\u0026#39;page\u0026#39;: 1, \u0026#39;per_page\u0026#39;: 10} headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\u0026#39;} requests_obj = requests.post(\u0026#34;http://httpbin.org/post\u0026#34;, json=payload, headers=headers) print(requests_obj.request.headers) 发送到服务器的请求头可以使用 requests_obj.request.headers 来查看：\n\u0026gt;\u0026gt;\u0026gt; print(requests_obj.request.headers) {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Content-Length\u0026#39;: \u0026#39;27\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;} 服务器返回的请求头可以使用 requests_obj.headers 来查看：\n\u0026gt;\u0026gt;\u0026gt; print(requests_obj.headers) {\u0026#39;Date\u0026#39;: \u0026#39;Thu, 30 Jun 2022 02:55:34 GMT\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Content-Length\u0026#39;: \u0026#39;531\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;close\u0026#39;, \u0026#39;Server\u0026#39;: \u0026#39;gunicorn/19.9.0\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Credentials\u0026#39;: \u0026#39;true\u0026#39;} Cookies 部分 url 需要携带 cookies 请求，可使用 cookies 参数指定要携带的 cookies。\nimport requests headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\u0026#39;} cookies = {\u0026#39;sessionid\u0026#39;:\u0026#39;tzwwdk68z05vou6g6624g52adavood5a\u0026#39;,\u0026#39;UserName\u0026#39;:\u0026#39;e3base\u0026#39;,\u0026#39;CurrentRole\u0026#39;:\u0026#39;%E7%AE%A1%E7%90%86%E5%91%98\u0026#39;,\u0026#39;CurrentCluster\u0026#39;:\u0026#39;JF_E3base410\u0026#39;} data = {\u0026#39;database\u0026#39;:\u0026#39;\u0026#39;} requests_obj = requests.post(\u0026#39;http://172.18.231.99:28011/JF_E3base560/e3resource/list/databases/\u0026#39;, headers=headers, cookies=cookies, json=data) # 输出 \u0026gt;\u0026gt;\u0026gt;print(requests_obj.status_code) \u0026gt;\u0026gt;\u0026gt;print(requests_obj.text) 200 {\u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: {\u0026#34;databases\u0026#34;: [\u0026#34;bdess8\u0026#34;, \u0026#34;default\u0026#34;, \u0026#34;doris_test\u0026#34;, \u0026#34;expand\u0026#34;, \u0026#34;fice13\u0026#34;, \u0026#34;hihihi\u0026#34;, \u0026#34;hive001\u0026#34;, \u0026#34;hive_euansu_02\u0026#34;, \u0026#34;hive_hbase_test\u0026#34;, \u0026#34;hive_jiajc\u0026#34;, \u0026#34;hiveeee\u0026#34;, \u0026#34;hivetset\u0026#34;, \u0026#34;huangzx_a\u0026#34;, \u0026#34;hudi\u0026#34;, \u0026#34;ice13\u0026#34;, \u0026#34;iceberg\u0026#34;, \u0026#34;iceberg_impala\u0026#34;, \u0026#34;iceberg_yupb\u0026#34;, \u0026#34;impala_test1\u0026#34;, \u0026#34;jiajc\u0026#34;, \u0026#34;klklklkl\u0026#34;, \u0026#34;niuxl\u0026#34;, \u0026#34;sensitive\u0026#34;, \u0026#34;sice\u0026#34;, \u0026#34;spark_iceberg\u0026#34;, \u0026#34;sql_quality\u0026#34;, \u0026#34;suwh_a\u0026#34;, \u0026#34;suwh_pri\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;test0220426\u0026#34;, \u0026#34;test20220425\u0026#34;, \u0026#34;test20220426\u0026#34;, \u0026#34;test20220509\u0026#34;, \u0026#34;test20220510\u0026#34;, \u0026#34;test202205102\u0026#34;, \u0026#34;test202205103\u0026#34;, \u0026#34;test2022042505\u0026#34;, \u0026#34;test2022042603\u0026#34;, \u0026#34;test2022042604\u0026#34;, \u0026#34;test2022042607\u0026#34;, \u0026#34;test2022042655\u0026#34;, \u0026#34;test2022042660\u0026#34;, \u0026#34;test2022052303\u0026#34;, \u0026#34;test2022052304\u0026#34;, \u0026#34;test2022052305\u0026#34;, \u0026#34;test_euansu_hive\u0026#34;, \u0026#34;testdb\u0026#34;, \u0026#34;tpcds_bin_partitioned_orc_2\u0026#34;, \u0026#34;tpcds_text_2\u0026#34;, \u0026#34;tt_renjy06_db\u0026#34;, \u0026#34;wanglei_hive\u0026#34;, \u0026#34;weiqm\u0026#34;, \u0026#34;weizy\u0026#34;, \u0026#34;youky_hdfs\u0026#34;, \u0026#34;youky_hive\u0026#34;, \u0026#34;youky_zuhu2\u0026#34;, \u0026#34;youyou\u0026#34;, \u0026#34;yupb\u0026#34;, \u0026#34;yupb002\u0026#34;, \u0026#34;zhangxrtest\u0026#34;]}} 身份认证 基本身份认证 基本身份认证（HTTP Basic Auth）是使用账号密码进行的简单认证，requests 提供了 HTTPBasicAuth 实现基本身份认证。\nimport requests from requests.auth import HTTPBasicAuth headers = {\u0026#39;X-Requested-By\u0026#39;: \u0026#39;ambari\u0026#39;} params = {\u0026#39;fields\u0026#39;:\u0026#39;Clusters/desired_configs\u0026#39;} requests_obj = requests.get(\u0026#39;http://172.18.231.130:8080/api/v1/clusters/E3baseCluster?fields=Clusters/desired_configs\u0026#39;, headers=headers, params=params, auth=HTTPBasicAuth(\u0026#39;admin\u0026#39;, \u0026#39;admin\u0026#39;)) # 输出 \u0026gt;\u0026gt;\u0026gt;print(requests_obj.status_code) \u0026gt;\u0026gt;\u0026gt;print(requests_obj.text) 200 { \u0026#34;href\u0026#34; : \u0026#34;http://172.18.231.130:8080/api/v1/clusters/E3baseCluster?fields=Clusters/desired_configs\u0026amp;fields=Clusters/desired_configs\u0026#34;, \u0026#34;Clusters\u0026#34; : { \u0026#34;cluster_name\u0026#34; : \u0026#34;E3baseCluster\u0026#34;, \u0026#34;desired_configs\u0026#34; : { \u0026#34;admin-properties\u0026#34; : { \u0026#34;tag\u0026#34; : \u0026#34;9c2a7808-dce6-477d-8dd8-00c8b1653e12\u0026#34;, \u0026#34;version\u0026#34; : 6 }, ... \u0026#34;zookeeper-logsearch-conf\u0026#34; : { \u0026#34;tag\u0026#34; : \u0026#34;67ccad57-abbd-498b-bf4c-b161b098a32f\u0026#34;, \u0026#34;version\u0026#34; : 1 } } } } HTTP 响应 HTTP响应基本概念 HTTP 响应与 HTTP 请求相似，由三部分组成：\n状态行： 响应头： 响应正文 requests 方法实践 使用 requests.* 发送请求时， requests 做了以下两件事：\n构建一个 requests 对象，该对象会根据请求方法或相关参数发起 HTTP 请求； 服务器返回响应时，会产生一个 response 对象，该响应对象包含服务器返回的所有信息，也包含原来创建的 requests 对象。 对于响应状态码，可以访问响应对象的 status_code 属性：\nimport requests requests_obj = requests.get(\u0026#34;http://httpbin.org/get\u0026#34;) print requests_obj.status_code # 输出 200 对于响应正文，可以使用多种方式读取，例：\n普通响应，使用 requests_obj.text 获取； JSON响应，使用 requests_obj.json() 获取； 二进制响应，使用 requests_obj.content 获取； 原始响应，使用 requests_obj.raw 获取； 普通响应 使用 requests_obj.text 来读取 unicode 形式的响应，例：\nimport requests requests_obj = requests.get(\u0026#34;https://github.com/timeline.json\u0026#34;) # 输出 \u0026gt;\u0026gt;\u0026gt;print(requests_obj.text) \u0026gt;\u0026gt;\u0026gt;print(requests_obj.encoding) {\u0026#34;message\u0026#34;:\u0026#34;Hello there, wayfaring stranger. If you’re reading this then you probably didn’t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.\u0026#34;,\u0026#34;documentation_url\u0026#34;:\u0026#34;https://docs.github.com/v3/activity/events/#list-public-events\u0026#34;} utf-8 JSON 响应 对于 JSON 格式的响应，可以使用 json() 的方法把返回的数据解析成 Python 对象。\nimport requests requests_obj = requests.get(\u0026#34;https://github.com/timeline.json\u0026#34;) # 输出 \u0026gt;\u0026gt;\u0026gt;print(requests_obj.json()) {\u0026#39;message\u0026#39;: \u0026#39;Hello there, wayfaring stranger. If you’re reading this then you probably didn’t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.\u0026#39;, \u0026#39;documentation_url\u0026#39;: \u0026#39;https://docs.github.com/v3/activity/events/#list-public-events\u0026#39;} 如响应的格式不是 JSON 格式，使用 json() 方法解析，会抛出错误。\n二进制响应 使用 contenet 属性可以获取二进制数据，例如使用返回的二进制数据进行文件的传输：\nimport os import requests url = \u0026#39;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\u0026#39; requests_obj = requests.get(url) image_data = requests_obj.content with open(\u0026#39;D:/study/Python/baidu.png\u0026#39;, \u0026#39;wb\u0026#39;) as fout: fout.write(image_data) filelist = os.listdir(\u0026#39;D:/study/Python\u0026#39;) # 输出 \u0026gt;\u0026gt;\u0026gt;print(filelist) [\u0026#39;baidu.png\u0026#39;, \u0026#39;Python基础.assets\u0026#39;, \u0026#39;Python基础.md\u0026#39;, \u0026#39;Python高性能编程学习笔记.md\u0026#39;, \u0026#39;[异步图书].Python高性能编程.pdf\u0026#39;] 原始响应 获取响应的原始数据，可以通过 raw 属性实现，但在发送请求时需要设置 stream=True ，例如：\nimport requests url = \u0026#39;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\u0026#39; requests_obj = requests.get(url,stream=True) # 输出 # obj.read(size) # size：要读取的字节数 \u0026gt;\u0026gt;\u0026gt;print(requests_obj.raw) \u0026gt;\u0026gt;\u0026gt;print(requests_obj.raw.read(10)) \u0026lt;urllib3.response.HTTPResponse object at 0x000001DE74E461C8\u0026gt; b\u0026#39;\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\u0026#39; 重定向 requests 会自动处理重定向的操作，可以使用 history 属性追踪请求 url 的重定向操作，requests_obj.history 是一个 response 对象的列表，这个列表按照从最开始的 url 到重定向的 url 进行排序。\nimport requests headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\u0026#39;} requests_obj = requests.get(\u0026#39;https://toutiao.io/k/c32y51\u0026#39;,headers=headers) # 输出 \u0026gt;\u0026gt;\u0026gt;print(requests_obj.status_code) \u0026gt;\u0026gt;\u0026gt;print(requests_obj.history) for response_obj in requests_obj.history: print(response_obj.url) 200 [\u0026lt;Response [302]\u0026gt;, \u0026lt;Response [301]\u0026gt;, \u0026lt;Response [302]\u0026gt;] https://toutiao.io/k/c32y51 http://www.jianshu.com/p/490441391db6?hmsr=toutiao.io\u0026amp;utm_campaign=toutiao.io\u0026amp;utm_medium=toutiao.io\u0026amp;utm_source=toutiao.io https://www.jianshu.com/p/490441391db6?hmsr=toutiao.io\u0026amp;utm_campaign=toutiao.io\u0026amp;utm_medium=toutiao.io\u0026amp;utm_source=toutiao.io 循环处理 requests_obj.history 可以追踪到 url 重定向后的 response 对象，打印 response.url 可以看到重定向的 url 。\n如果请求方法是 GET、POST、PUT、OPTIONS、PATCH 或 DELETE，可以通过 all_redirects 参数禁止重定向：\nimport requests headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)\u0026#39;} requests_obj = requests.get(\u0026#39;https://toutiao.io/k/c32y51\u0026#39;,headers=headers,allow_redirects=False) # 输出 \u0026gt;\u0026gt;\u0026gt;print(requests_obj.status_code) \u0026gt;\u0026gt;\u0026gt;print(requests_obj.history) 302 [] Virtualenv 虚拟环境 virtualenv 用来创建对立的 Python环境，可以将项目与实际的环境独立开，在这个环境中安装、卸载软件而不会影响到其他项目，解决了不同项目可能存在的依赖包版本的冲突问题。\n安装 virtualenv pip install -i https://pypi.mirrors.ustc.edu.cn/simple/ virtualenv 操作步骤 创建目录 # 创建目录 mkdir virtualEnv # 进入创建的目录 cd virtualEnv 创建虚拟环境 virtualenv venv 激活虚拟环境 .\\venv\\Scripts\\activate 激活虚拟环境后，会出现一个（venv）前缀，表明这是一个 Python 的 venv 虚拟环境。\n在 venv 环境下，用 pip 安装的包都被安装到 venv 这个环境下，系统Python环境不受任何影响。也就是说，venv 环境是专门针对 virtualEnv 这个应用创建的。\n","date":"2021-07-25T09:47:00+08:00","image":"https://euansu123.github.io/img/python.jpg","permalink":"https://euansu123.github.io/post/python_base_package/","title":"Python 基础库"}]